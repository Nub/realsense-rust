/* automatically generated by rust-bindgen */

pub const RS2_PRODUCT_LINE_ANY: u32 = 255;
pub const RS2_PRODUCT_LINE_ANY_INTEL: u32 = 254;
pub const RS2_PRODUCT_LINE_NON_INTEL: u32 = 1;
pub const RS2_PRODUCT_LINE_D400: u32 = 2;
pub const RS2_PRODUCT_LINE_SR300: u32 = 4;
pub const RS2_PRODUCT_LINE_L500: u32 = 8;
pub const RS2_PRODUCT_LINE_T200: u32 = 16;
pub const RS2_PRODUCT_LINE_DEPTH: u32 = 14;
pub const RS2_PRODUCT_LINE_TRACKING: u32 = 16;
pub const RS2_UNSIGNED_UPDATE_MODE_UPDATE: u32 = 0;
pub const RS2_UNSIGNED_UPDATE_MODE_READ_ONLY: u32 = 1;
pub const RS2_UNSIGNED_UPDATE_MODE_FULL: u32 = 2;
pub const RS2_API_MAJOR_VERSION: u32 = 2;
pub const RS2_API_MINOR_VERSION: u32 = 32;
pub const RS2_API_PATCH_VERSION: u32 = 1;
pub const RS2_API_BUILD_VERSION: u32 = 0;
pub const RS2_API_VERSION: u32 = 23201;
pub const RS2_DEFAULT_TIMEOUT: u32 = 15000;
pub const rs2_notification_category_RS2_NOTIFICATION_CATEGORY_FRAMES_TIMEOUT:
    rs2_notification_category = 0;
pub const rs2_notification_category_RS2_NOTIFICATION_CATEGORY_FRAME_CORRUPTED:
    rs2_notification_category = 1;
pub const rs2_notification_category_RS2_NOTIFICATION_CATEGORY_HARDWARE_ERROR:
    rs2_notification_category = 2;
pub const rs2_notification_category_RS2_NOTIFICATION_CATEGORY_HARDWARE_EVENT:
    rs2_notification_category = 3;
pub const rs2_notification_category_RS2_NOTIFICATION_CATEGORY_UNKNOWN_ERROR:
    rs2_notification_category = 4;
pub const rs2_notification_category_RS2_NOTIFICATION_CATEGORY_FIRMWARE_UPDATE_RECOMMENDED:
    rs2_notification_category = 5;
pub const rs2_notification_category_RS2_NOTIFICATION_CATEGORY_POSE_RELOCALIZATION:
    rs2_notification_category = 6;
pub const rs2_notification_category_RS2_NOTIFICATION_CATEGORY_COUNT: rs2_notification_category = 7;
pub type rs2_notification_category = u32;
extern "C" {
    pub fn rs2_notification_category_to_string(
        category: rs2_notification_category,
    ) -> *const ::std::os::raw::c_char;
}
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_UNKNOWN: rs2_exception_type = 0;
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_CAMERA_DISCONNECTED: rs2_exception_type = 1;
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_BACKEND: rs2_exception_type = 2;
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_INVALID_VALUE: rs2_exception_type = 3;
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_WRONG_API_CALL_SEQUENCE: rs2_exception_type = 4;
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_NOT_IMPLEMENTED: rs2_exception_type = 5;
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_DEVICE_IN_RECOVERY_MODE: rs2_exception_type = 6;
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_IO: rs2_exception_type = 7;
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_COUNT: rs2_exception_type = 8;
pub type rs2_exception_type = u32;
extern "C" {
    pub fn rs2_exception_type_to_string(type_: rs2_exception_type)
        -> *const ::std::os::raw::c_char;
}
pub const rs2_distortion_RS2_DISTORTION_NONE: rs2_distortion = 0;
pub const rs2_distortion_RS2_DISTORTION_MODIFIED_BROWN_CONRADY: rs2_distortion = 1;
pub const rs2_distortion_RS2_DISTORTION_INVERSE_BROWN_CONRADY: rs2_distortion = 2;
pub const rs2_distortion_RS2_DISTORTION_FTHETA: rs2_distortion = 3;
pub const rs2_distortion_RS2_DISTORTION_BROWN_CONRADY: rs2_distortion = 4;
pub const rs2_distortion_RS2_DISTORTION_KANNALA_BRANDT4: rs2_distortion = 5;
pub const rs2_distortion_RS2_DISTORTION_COUNT: rs2_distortion = 6;
pub type rs2_distortion = u32;
extern "C" {
    pub fn rs2_distortion_to_string(distortion: rs2_distortion) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_intrinsics {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub ppx: f32,
    pub ppy: f32,
    pub fx: f32,
    pub fy: f32,
    pub model: rs2_distortion,
    pub coeffs: [f32; 5usize],
}
#[test]
fn bindgen_test_layout_rs2_intrinsics() {
    assert_eq!(
        ::std::mem::size_of::<rs2_intrinsics>(),
        48usize,
        concat!("Size of: ", stringify!(rs2_intrinsics))
    );
    assert_eq!(
        ::std::mem::align_of::<rs2_intrinsics>(),
        4usize,
        concat!("Alignment of ", stringify!(rs2_intrinsics))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_intrinsics>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_intrinsics),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_intrinsics>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_intrinsics),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_intrinsics>())).ppx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_intrinsics),
            "::",
            stringify!(ppx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_intrinsics>())).ppy as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_intrinsics),
            "::",
            stringify!(ppy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_intrinsics>())).fx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_intrinsics),
            "::",
            stringify!(fx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_intrinsics>())).fy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_intrinsics),
            "::",
            stringify!(fy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_intrinsics>())).model as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_intrinsics),
            "::",
            stringify!(model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_intrinsics>())).coeffs as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_intrinsics),
            "::",
            stringify!(coeffs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_motion_device_intrinsic {
    pub data: [[f32; 4usize]; 3usize],
    pub noise_variances: [f32; 3usize],
    pub bias_variances: [f32; 3usize],
}
#[test]
fn bindgen_test_layout_rs2_motion_device_intrinsic() {
    assert_eq!(
        ::std::mem::size_of::<rs2_motion_device_intrinsic>(),
        72usize,
        concat!("Size of: ", stringify!(rs2_motion_device_intrinsic))
    );
    assert_eq!(
        ::std::mem::align_of::<rs2_motion_device_intrinsic>(),
        4usize,
        concat!("Alignment of ", stringify!(rs2_motion_device_intrinsic))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rs2_motion_device_intrinsic>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_motion_device_intrinsic),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rs2_motion_device_intrinsic>())).noise_variances as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_motion_device_intrinsic),
            "::",
            stringify!(noise_variances)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rs2_motion_device_intrinsic>())).bias_variances as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_motion_device_intrinsic),
            "::",
            stringify!(bias_variances)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_vertex {
    pub xyz: [f32; 3usize],
}
#[test]
fn bindgen_test_layout_rs2_vertex() {
    assert_eq!(
        ::std::mem::size_of::<rs2_vertex>(),
        12usize,
        concat!("Size of: ", stringify!(rs2_vertex))
    );
    assert_eq!(
        ::std::mem::align_of::<rs2_vertex>(),
        4usize,
        concat!("Alignment of ", stringify!(rs2_vertex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_vertex>())).xyz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_vertex),
            "::",
            stringify!(xyz)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_pixel {
    pub ij: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout_rs2_pixel() {
    assert_eq!(
        ::std::mem::size_of::<rs2_pixel>(),
        8usize,
        concat!("Size of: ", stringify!(rs2_pixel))
    );
    assert_eq!(
        ::std::mem::align_of::<rs2_pixel>(),
        4usize,
        concat!("Alignment of ", stringify!(rs2_pixel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pixel>())).ij as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pixel),
            "::",
            stringify!(ij)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_vector {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_rs2_vector() {
    assert_eq!(
        ::std::mem::size_of::<rs2_vector>(),
        12usize,
        concat!("Size of: ", stringify!(rs2_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<rs2_vector>(),
        4usize,
        concat!("Alignment of ", stringify!(rs2_vector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_vector>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_vector),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_vector>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_vector),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_vector>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_vector),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_quaternion {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_rs2_quaternion() {
    assert_eq!(
        ::std::mem::size_of::<rs2_quaternion>(),
        16usize,
        concat!("Size of: ", stringify!(rs2_quaternion))
    );
    assert_eq!(
        ::std::mem::align_of::<rs2_quaternion>(),
        4usize,
        concat!("Alignment of ", stringify!(rs2_quaternion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_quaternion>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_quaternion),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_quaternion>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_quaternion),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_quaternion>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_quaternion),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_quaternion>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_quaternion),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_pose {
    pub translation: rs2_vector,
    pub velocity: rs2_vector,
    pub acceleration: rs2_vector,
    pub rotation: rs2_quaternion,
    pub angular_velocity: rs2_vector,
    pub angular_acceleration: rs2_vector,
    pub tracker_confidence: ::std::os::raw::c_uint,
    pub mapper_confidence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rs2_pose() {
    assert_eq!(
        ::std::mem::size_of::<rs2_pose>(),
        84usize,
        concat!("Size of: ", stringify!(rs2_pose))
    );
    assert_eq!(
        ::std::mem::align_of::<rs2_pose>(),
        4usize,
        concat!("Alignment of ", stringify!(rs2_pose))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pose>())).translation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pose),
            "::",
            stringify!(translation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pose>())).velocity as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pose),
            "::",
            stringify!(velocity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pose>())).acceleration as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pose),
            "::",
            stringify!(acceleration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pose>())).rotation as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pose),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pose>())).angular_velocity as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pose),
            "::",
            stringify!(angular_velocity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pose>())).angular_acceleration as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pose),
            "::",
            stringify!(angular_acceleration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pose>())).tracker_confidence as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pose),
            "::",
            stringify!(tracker_confidence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pose>())).mapper_confidence as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pose),
            "::",
            stringify!(mapper_confidence)
        )
    );
}
pub const rs2_log_severity_RS2_LOG_SEVERITY_DEBUG: rs2_log_severity = 0;
pub const rs2_log_severity_RS2_LOG_SEVERITY_INFO: rs2_log_severity = 1;
pub const rs2_log_severity_RS2_LOG_SEVERITY_WARN: rs2_log_severity = 2;
pub const rs2_log_severity_RS2_LOG_SEVERITY_ERROR: rs2_log_severity = 3;
pub const rs2_log_severity_RS2_LOG_SEVERITY_FATAL: rs2_log_severity = 4;
pub const rs2_log_severity_RS2_LOG_SEVERITY_NONE: rs2_log_severity = 5;
pub const rs2_log_severity_RS2_LOG_SEVERITY_COUNT: rs2_log_severity = 6;
pub type rs2_log_severity = u32;
extern "C" {
    pub fn rs2_log_severity_to_string(info: rs2_log_severity) -> *const ::std::os::raw::c_char;
}
pub const rs2_extension_RS2_EXTENSION_UNKNOWN: rs2_extension = 0;
pub const rs2_extension_RS2_EXTENSION_DEBUG: rs2_extension = 1;
pub const rs2_extension_RS2_EXTENSION_INFO: rs2_extension = 2;
pub const rs2_extension_RS2_EXTENSION_MOTION: rs2_extension = 3;
pub const rs2_extension_RS2_EXTENSION_OPTIONS: rs2_extension = 4;
pub const rs2_extension_RS2_EXTENSION_VIDEO: rs2_extension = 5;
pub const rs2_extension_RS2_EXTENSION_ROI: rs2_extension = 6;
pub const rs2_extension_RS2_EXTENSION_DEPTH_SENSOR: rs2_extension = 7;
pub const rs2_extension_RS2_EXTENSION_VIDEO_FRAME: rs2_extension = 8;
pub const rs2_extension_RS2_EXTENSION_MOTION_FRAME: rs2_extension = 9;
pub const rs2_extension_RS2_EXTENSION_COMPOSITE_FRAME: rs2_extension = 10;
pub const rs2_extension_RS2_EXTENSION_POINTS: rs2_extension = 11;
pub const rs2_extension_RS2_EXTENSION_DEPTH_FRAME: rs2_extension = 12;
pub const rs2_extension_RS2_EXTENSION_ADVANCED_MODE: rs2_extension = 13;
pub const rs2_extension_RS2_EXTENSION_RECORD: rs2_extension = 14;
pub const rs2_extension_RS2_EXTENSION_VIDEO_PROFILE: rs2_extension = 15;
pub const rs2_extension_RS2_EXTENSION_PLAYBACK: rs2_extension = 16;
pub const rs2_extension_RS2_EXTENSION_DEPTH_STEREO_SENSOR: rs2_extension = 17;
pub const rs2_extension_RS2_EXTENSION_DISPARITY_FRAME: rs2_extension = 18;
pub const rs2_extension_RS2_EXTENSION_MOTION_PROFILE: rs2_extension = 19;
pub const rs2_extension_RS2_EXTENSION_POSE_FRAME: rs2_extension = 20;
pub const rs2_extension_RS2_EXTENSION_POSE_PROFILE: rs2_extension = 21;
pub const rs2_extension_RS2_EXTENSION_TM2: rs2_extension = 22;
pub const rs2_extension_RS2_EXTENSION_SOFTWARE_DEVICE: rs2_extension = 23;
pub const rs2_extension_RS2_EXTENSION_SOFTWARE_SENSOR: rs2_extension = 24;
pub const rs2_extension_RS2_EXTENSION_DECIMATION_FILTER: rs2_extension = 25;
pub const rs2_extension_RS2_EXTENSION_THRESHOLD_FILTER: rs2_extension = 26;
pub const rs2_extension_RS2_EXTENSION_DISPARITY_FILTER: rs2_extension = 27;
pub const rs2_extension_RS2_EXTENSION_SPATIAL_FILTER: rs2_extension = 28;
pub const rs2_extension_RS2_EXTENSION_TEMPORAL_FILTER: rs2_extension = 29;
pub const rs2_extension_RS2_EXTENSION_HOLE_FILLING_FILTER: rs2_extension = 30;
pub const rs2_extension_RS2_EXTENSION_ZERO_ORDER_FILTER: rs2_extension = 31;
pub const rs2_extension_RS2_EXTENSION_RECOMMENDED_FILTERS: rs2_extension = 32;
pub const rs2_extension_RS2_EXTENSION_POSE: rs2_extension = 33;
pub const rs2_extension_RS2_EXTENSION_POSE_SENSOR: rs2_extension = 34;
pub const rs2_extension_RS2_EXTENSION_WHEEL_ODOMETER: rs2_extension = 35;
pub const rs2_extension_RS2_EXTENSION_GLOBAL_TIMER: rs2_extension = 36;
pub const rs2_extension_RS2_EXTENSION_UPDATABLE: rs2_extension = 37;
pub const rs2_extension_RS2_EXTENSION_UPDATE_DEVICE: rs2_extension = 38;
pub const rs2_extension_RS2_EXTENSION_L500_DEPTH_SENSOR: rs2_extension = 39;
pub const rs2_extension_RS2_EXTENSION_TM2_SENSOR: rs2_extension = 40;
pub const rs2_extension_RS2_EXTENSION_AUTO_CALIBRATED_DEVICE: rs2_extension = 41;
pub const rs2_extension_RS2_EXTENSION_COLOR_SENSOR: rs2_extension = 42;
pub const rs2_extension_RS2_EXTENSION_MOTION_SENSOR: rs2_extension = 43;
pub const rs2_extension_RS2_EXTENSION_FISHEYE_SENSOR: rs2_extension = 44;
pub const rs2_extension_RS2_EXTENSION_DEPTH_HUFFMAN_DECODER: rs2_extension = 45;
pub const rs2_extension_RS2_EXTENSION_COUNT: rs2_extension = 46;
pub type rs2_extension = u32;
extern "C" {
    pub fn rs2_extension_type_to_string(type_: rs2_extension) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_extension_to_string(type_: rs2_extension) -> *const ::std::os::raw::c_char;
}
pub const rs2_matchers_RS2_MATCHER_DI: rs2_matchers = 0;
pub const rs2_matchers_RS2_MATCHER_DI_C: rs2_matchers = 1;
pub const rs2_matchers_RS2_MATCHER_DLR_C: rs2_matchers = 2;
pub const rs2_matchers_RS2_MATCHER_DLR: rs2_matchers = 3;
pub const rs2_matchers_RS2_MATCHER_DIC: rs2_matchers = 4;
pub const rs2_matchers_RS2_MATCHER_DIC_C: rs2_matchers = 5;
pub const rs2_matchers_RS2_MATCHER_DEFAULT: rs2_matchers = 6;
pub const rs2_matchers_RS2_MATCHER_COUNT: rs2_matchers = 7;
pub type rs2_matchers = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_device_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_error {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_raw_data_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_frame {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_frame_queue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_pipeline {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_pipeline_profile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_config {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_device_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_stream_profile_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_processing_block_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_stream_profile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_frame_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_log_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_syncer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_device_serializer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_source {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_processing_block {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_frame_processor_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_playback_status_changed_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_update_progress_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_device_hub {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_sensor_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_sensor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_options {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_options_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_devices_changed_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_notification {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_notifications_callback {
    _unused: [u8; 0],
}
pub type rs2_notification_callback_ptr = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut rs2_notification, arg2: *mut ::std::os::raw::c_void),
>;
pub type rs2_devices_changed_callback_ptr = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut rs2_device_list,
        arg2: *mut rs2_device_list,
        arg3: *mut ::std::os::raw::c_void,
    ),
>;
pub type rs2_frame_callback_ptr = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut rs2_frame, arg2: *mut ::std::os::raw::c_void),
>;
pub type rs2_frame_processor_callback_ptr = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut rs2_frame,
        arg2: *mut rs2_source,
        arg3: *mut ::std::os::raw::c_void,
    ),
>;
pub type rs2_update_progress_callback_ptr =
    ::std::option::Option<unsafe extern "C" fn(arg1: f32, arg2: *mut ::std::os::raw::c_void)>;
pub type rs2_time_t = f64;
pub type rs2_metadata_type = ::std::os::raw::c_longlong;
extern "C" {
    pub fn rs2_create_error(
        what: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        args: *const ::std::os::raw::c_char,
        type_: rs2_exception_type,
    ) -> *mut rs2_error;
}
extern "C" {
    pub fn rs2_get_librealsense_exception_type(error: *const rs2_error) -> rs2_exception_type;
}
extern "C" {
    pub fn rs2_get_failed_function(error: *const rs2_error) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_get_failed_args(error: *const rs2_error) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_get_error_message(error: *const rs2_error) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_free_error(error: *mut rs2_error);
}
pub const rs2_camera_info_RS2_CAMERA_INFO_NAME: rs2_camera_info = 0;
pub const rs2_camera_info_RS2_CAMERA_INFO_SERIAL_NUMBER: rs2_camera_info = 1;
pub const rs2_camera_info_RS2_CAMERA_INFO_FIRMWARE_VERSION: rs2_camera_info = 2;
pub const rs2_camera_info_RS2_CAMERA_INFO_RECOMMENDED_FIRMWARE_VERSION: rs2_camera_info = 3;
pub const rs2_camera_info_RS2_CAMERA_INFO_PHYSICAL_PORT: rs2_camera_info = 4;
pub const rs2_camera_info_RS2_CAMERA_INFO_DEBUG_OP_CODE: rs2_camera_info = 5;
pub const rs2_camera_info_RS2_CAMERA_INFO_ADVANCED_MODE: rs2_camera_info = 6;
pub const rs2_camera_info_RS2_CAMERA_INFO_PRODUCT_ID: rs2_camera_info = 7;
pub const rs2_camera_info_RS2_CAMERA_INFO_CAMERA_LOCKED: rs2_camera_info = 8;
pub const rs2_camera_info_RS2_CAMERA_INFO_USB_TYPE_DESCRIPTOR: rs2_camera_info = 9;
pub const rs2_camera_info_RS2_CAMERA_INFO_PRODUCT_LINE: rs2_camera_info = 10;
pub const rs2_camera_info_RS2_CAMERA_INFO_ASIC_SERIAL_NUMBER: rs2_camera_info = 11;
pub const rs2_camera_info_RS2_CAMERA_INFO_FIRMWARE_UPDATE_ID: rs2_camera_info = 12;
pub const rs2_camera_info_RS2_CAMERA_INFO_COUNT: rs2_camera_info = 13;
pub type rs2_camera_info = u32;
extern "C" {
    pub fn rs2_camera_info_to_string(info: rs2_camera_info) -> *const ::std::os::raw::c_char;
}
pub const rs2_stream_RS2_STREAM_ANY: rs2_stream = 0;
pub const rs2_stream_RS2_STREAM_DEPTH: rs2_stream = 1;
pub const rs2_stream_RS2_STREAM_COLOR: rs2_stream = 2;
pub const rs2_stream_RS2_STREAM_INFRARED: rs2_stream = 3;
pub const rs2_stream_RS2_STREAM_FISHEYE: rs2_stream = 4;
pub const rs2_stream_RS2_STREAM_GYRO: rs2_stream = 5;
pub const rs2_stream_RS2_STREAM_ACCEL: rs2_stream = 6;
pub const rs2_stream_RS2_STREAM_GPIO: rs2_stream = 7;
pub const rs2_stream_RS2_STREAM_POSE: rs2_stream = 8;
pub const rs2_stream_RS2_STREAM_CONFIDENCE: rs2_stream = 9;
pub const rs2_stream_RS2_STREAM_COUNT: rs2_stream = 10;
pub type rs2_stream = u32;
extern "C" {
    pub fn rs2_stream_to_string(stream: rs2_stream) -> *const ::std::os::raw::c_char;
}
pub const rs2_format_RS2_FORMAT_ANY: rs2_format = 0;
pub const rs2_format_RS2_FORMAT_Z16: rs2_format = 1;
pub const rs2_format_RS2_FORMAT_DISPARITY16: rs2_format = 2;
pub const rs2_format_RS2_FORMAT_XYZ32F: rs2_format = 3;
pub const rs2_format_RS2_FORMAT_YUYV: rs2_format = 4;
pub const rs2_format_RS2_FORMAT_RGB8: rs2_format = 5;
pub const rs2_format_RS2_FORMAT_BGR8: rs2_format = 6;
pub const rs2_format_RS2_FORMAT_RGBA8: rs2_format = 7;
pub const rs2_format_RS2_FORMAT_BGRA8: rs2_format = 8;
pub const rs2_format_RS2_FORMAT_Y8: rs2_format = 9;
pub const rs2_format_RS2_FORMAT_Y16: rs2_format = 10;
pub const rs2_format_RS2_FORMAT_RAW10: rs2_format = 11;
pub const rs2_format_RS2_FORMAT_RAW16: rs2_format = 12;
pub const rs2_format_RS2_FORMAT_RAW8: rs2_format = 13;
pub const rs2_format_RS2_FORMAT_UYVY: rs2_format = 14;
pub const rs2_format_RS2_FORMAT_MOTION_RAW: rs2_format = 15;
pub const rs2_format_RS2_FORMAT_MOTION_XYZ32F: rs2_format = 16;
pub const rs2_format_RS2_FORMAT_GPIO_RAW: rs2_format = 17;
pub const rs2_format_RS2_FORMAT_6DOF: rs2_format = 18;
pub const rs2_format_RS2_FORMAT_DISPARITY32: rs2_format = 19;
pub const rs2_format_RS2_FORMAT_Y10BPACK: rs2_format = 20;
pub const rs2_format_RS2_FORMAT_DISTANCE: rs2_format = 21;
pub const rs2_format_RS2_FORMAT_MJPEG: rs2_format = 22;
pub const rs2_format_RS2_FORMAT_Y8I: rs2_format = 23;
pub const rs2_format_RS2_FORMAT_Y12I: rs2_format = 24;
pub const rs2_format_RS2_FORMAT_INZI: rs2_format = 25;
pub const rs2_format_RS2_FORMAT_INVI: rs2_format = 26;
pub const rs2_format_RS2_FORMAT_W10: rs2_format = 27;
pub const rs2_format_RS2_FORMAT_Z16H: rs2_format = 28;
pub const rs2_format_RS2_FORMAT_COUNT: rs2_format = 29;
pub type rs2_format = u32;
extern "C" {
    pub fn rs2_format_to_string(format: rs2_format) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_extrinsics {
    pub rotation: [f32; 9usize],
    pub translation: [f32; 3usize],
}
#[test]
fn bindgen_test_layout_rs2_extrinsics() {
    assert_eq!(
        ::std::mem::size_of::<rs2_extrinsics>(),
        48usize,
        concat!("Size of: ", stringify!(rs2_extrinsics))
    );
    assert_eq!(
        ::std::mem::align_of::<rs2_extrinsics>(),
        4usize,
        concat!("Alignment of ", stringify!(rs2_extrinsics))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_extrinsics>())).rotation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_extrinsics),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_extrinsics>())).translation as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_extrinsics),
            "::",
            stringify!(translation)
        )
    );
}
extern "C" {
    pub fn rs2_delete_sensor_list(info_list: *mut rs2_sensor_list);
}
extern "C" {
    pub fn rs2_get_sensors_count(
        info_list: *const rs2_sensor_list,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_delete_sensor(sensor: *mut rs2_sensor);
}
extern "C" {
    pub fn rs2_create_sensor(
        list: *const rs2_sensor_list,
        index: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_sensor;
}
extern "C" {
    pub fn rs2_create_device_from_sensor(
        sensor: *const rs2_sensor,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device;
}
extern "C" {
    pub fn rs2_get_sensor_info(
        sensor: *const rs2_sensor,
        info: rs2_camera_info,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_supports_sensor_info(
        sensor: *const rs2_sensor,
        info: rs2_camera_info,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_is_sensor_extendable_to(
        sensor: *const rs2_sensor,
        extension: rs2_extension,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_get_depth_scale(sensor: *mut rs2_sensor, error: *mut *mut rs2_error) -> f32;
}
extern "C" {
    pub fn rs2_depth_stereo_frame_get_baseline(
        frame_ref: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> f32;
}
extern "C" {
    pub fn rs2_get_stereo_baseline(sensor: *mut rs2_sensor, error: *mut *mut rs2_error) -> f32;
}
extern "C" {
    pub fn rs2_set_region_of_interest(
        sensor: *const rs2_sensor,
        min_x: ::std::os::raw::c_int,
        min_y: ::std::os::raw::c_int,
        max_x: ::std::os::raw::c_int,
        max_y: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_get_region_of_interest(
        sensor: *const rs2_sensor,
        min_x: *mut ::std::os::raw::c_int,
        min_y: *mut ::std::os::raw::c_int,
        max_x: *mut ::std::os::raw::c_int,
        max_y: *mut ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_open(
        device: *mut rs2_sensor,
        profile: *const rs2_stream_profile,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_open_multiple(
        device: *mut rs2_sensor,
        profiles: *mut *const rs2_stream_profile,
        count: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_close(sensor: *const rs2_sensor, error: *mut *mut rs2_error);
}
extern "C" {
    pub fn rs2_start(
        sensor: *const rs2_sensor,
        on_frame: rs2_frame_callback_ptr,
        user: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_start_cpp(
        sensor: *const rs2_sensor,
        callback: *mut rs2_frame_callback,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_start_queue(
        sensor: *const rs2_sensor,
        queue: *mut rs2_frame_queue,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_stop(sensor: *const rs2_sensor, error: *mut *mut rs2_error);
}
extern "C" {
    pub fn rs2_set_notifications_callback(
        sensor: *const rs2_sensor,
        on_notification: rs2_notification_callback_ptr,
        user: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_set_notifications_callback_cpp(
        sensor: *const rs2_sensor,
        callback: *mut rs2_notifications_callback,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_get_notification_description(
        notification: *mut rs2_notification,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_get_notification_timestamp(
        notification: *mut rs2_notification,
        error: *mut *mut rs2_error,
    ) -> rs2_time_t;
}
extern "C" {
    pub fn rs2_get_notification_severity(
        notification: *mut rs2_notification,
        error: *mut *mut rs2_error,
    ) -> rs2_log_severity;
}
extern "C" {
    pub fn rs2_get_notification_category(
        notification: *mut rs2_notification,
        error: *mut *mut rs2_error,
    ) -> rs2_notification_category;
}
extern "C" {
    pub fn rs2_get_notification_serialized_data(
        notification: *mut rs2_notification,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_get_stream_profiles(
        device: *mut rs2_sensor,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_stream_profile_list;
}
extern "C" {
    pub fn rs2_get_stream_profile(
        list: *const rs2_stream_profile_list,
        index: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *const rs2_stream_profile;
}
extern "C" {
    pub fn rs2_get_stream_profile_data(
        mode: *const rs2_stream_profile,
        stream: *mut rs2_stream,
        format: *mut rs2_format,
        index: *mut ::std::os::raw::c_int,
        unique_id: *mut ::std::os::raw::c_int,
        framerate: *mut ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_set_stream_profile_data(
        mode: *mut rs2_stream_profile,
        stream: rs2_stream,
        index: ::std::os::raw::c_int,
        format: rs2_format,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_clone_stream_profile(
        mode: *const rs2_stream_profile,
        stream: rs2_stream,
        index: ::std::os::raw::c_int,
        format: rs2_format,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_stream_profile;
}
extern "C" {
    pub fn rs2_clone_video_stream_profile(
        mode: *const rs2_stream_profile,
        stream: rs2_stream,
        index: ::std::os::raw::c_int,
        format: rs2_format,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        intr: *const rs2_intrinsics,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_stream_profile;
}
extern "C" {
    pub fn rs2_delete_stream_profile(mode: *mut rs2_stream_profile);
}
extern "C" {
    pub fn rs2_stream_profile_is(
        mode: *const rs2_stream_profile,
        type_: rs2_extension,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_get_video_stream_resolution(
        mode: *const rs2_stream_profile,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_get_motion_intrinsics(
        mode: *const rs2_stream_profile,
        intrinsics: *mut rs2_motion_device_intrinsic,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_is_stream_profile_default(
        mode: *const rs2_stream_profile,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_get_stream_profiles_count(
        list: *const rs2_stream_profile_list,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_delete_stream_profiles_list(list: *mut rs2_stream_profile_list);
}
extern "C" {
    pub fn rs2_get_extrinsics(
        from: *const rs2_stream_profile,
        to: *const rs2_stream_profile,
        extrin: *mut rs2_extrinsics,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_register_extrinsics(
        from: *const rs2_stream_profile,
        to: *const rs2_stream_profile,
        extrin: rs2_extrinsics,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_get_video_stream_intrinsics(
        mode: *const rs2_stream_profile,
        intrinsics: *mut rs2_intrinsics,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_get_recommended_processing_blocks(
        sensor: *mut rs2_sensor,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block_list;
}
extern "C" {
    pub fn rs2_get_processing_block(
        list: *const rs2_processing_block_list,
        index: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_get_recommended_processing_blocks_count(
        list: *const rs2_processing_block_list,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_delete_recommended_processing_blocks(list: *mut rs2_processing_block_list);
}
extern "C" {
    pub fn rs2_import_localization_map(
        sensor: *const rs2_sensor,
        lmap_blob: *const ::std::os::raw::c_uchar,
        blob_size: ::std::os::raw::c_uint,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_export_localization_map(
        sensor: *const rs2_sensor,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    pub fn rs2_set_static_node(
        sensor: *const rs2_sensor,
        guid: *const ::std::os::raw::c_char,
        pos: rs2_vector,
        orient: rs2_quaternion,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_get_static_node(
        sensor: *const rs2_sensor,
        guid: *const ::std::os::raw::c_char,
        pos: *mut rs2_vector,
        orient: *mut rs2_quaternion,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_remove_static_node(
        sensor: *const rs2_sensor,
        guid: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_load_wheel_odometry_config(
        sensor: *const rs2_sensor,
        odometry_config_buf: *const ::std::os::raw::c_uchar,
        blob_size: ::std::os::raw::c_uint,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_send_wheel_odometry(
        sensor: *const rs2_sensor,
        wo_sensor_id: ::std::os::raw::c_char,
        frame_num: ::std::os::raw::c_uint,
        translational_velocity: rs2_vector,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_set_intrinsics(
        sensor: *const rs2_sensor,
        profile: *const rs2_stream_profile,
        intrinsics: *const rs2_intrinsics,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_set_extrinsics(
        from_sensor: *const rs2_sensor,
        from_profile: *const rs2_stream_profile,
        to_sensor: *mut rs2_sensor,
        to_profile: *const rs2_stream_profile,
        extrinsics: *const rs2_extrinsics,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_set_motion_device_intrinsics(
        sensor: *const rs2_sensor,
        profile: *const rs2_stream_profile,
        intrinsics: *const rs2_motion_device_intrinsic,
        error: *mut *mut rs2_error,
    );
}
pub const rs2_timestamp_domain_RS2_TIMESTAMP_DOMAIN_HARDWARE_CLOCK: rs2_timestamp_domain = 0;
pub const rs2_timestamp_domain_RS2_TIMESTAMP_DOMAIN_SYSTEM_TIME: rs2_timestamp_domain = 1;
pub const rs2_timestamp_domain_RS2_TIMESTAMP_DOMAIN_GLOBAL_TIME: rs2_timestamp_domain = 2;
pub const rs2_timestamp_domain_RS2_TIMESTAMP_DOMAIN_COUNT: rs2_timestamp_domain = 3;
pub type rs2_timestamp_domain = u32;
extern "C" {
    pub fn rs2_timestamp_domain_to_string(
        info: rs2_timestamp_domain,
    ) -> *const ::std::os::raw::c_char;
}
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_FRAME_COUNTER: rs2_frame_metadata_value = 0;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_FRAME_TIMESTAMP: rs2_frame_metadata_value = 1;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_SENSOR_TIMESTAMP: rs2_frame_metadata_value =
    2;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_ACTUAL_EXPOSURE: rs2_frame_metadata_value = 3;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_GAIN_LEVEL: rs2_frame_metadata_value = 4;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_AUTO_EXPOSURE: rs2_frame_metadata_value = 5;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_WHITE_BALANCE: rs2_frame_metadata_value = 6;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_TIME_OF_ARRIVAL: rs2_frame_metadata_value = 7;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_TEMPERATURE: rs2_frame_metadata_value = 8;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_BACKEND_TIMESTAMP: rs2_frame_metadata_value =
    9;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_ACTUAL_FPS: rs2_frame_metadata_value = 10;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_FRAME_LASER_POWER: rs2_frame_metadata_value =
    11;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_FRAME_LASER_POWER_MODE:
    rs2_frame_metadata_value = 12;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_EXPOSURE_PRIORITY: rs2_frame_metadata_value =
    13;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_EXPOSURE_ROI_LEFT: rs2_frame_metadata_value =
    14;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_EXPOSURE_ROI_RIGHT: rs2_frame_metadata_value =
    15;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_EXPOSURE_ROI_TOP: rs2_frame_metadata_value =
    16;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_EXPOSURE_ROI_BOTTOM:
    rs2_frame_metadata_value = 17;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_BRIGHTNESS: rs2_frame_metadata_value = 18;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_CONTRAST: rs2_frame_metadata_value = 19;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_SATURATION: rs2_frame_metadata_value = 20;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_SHARPNESS: rs2_frame_metadata_value = 21;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_AUTO_WHITE_BALANCE_TEMPERATURE:
    rs2_frame_metadata_value = 22;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_BACKLIGHT_COMPENSATION:
    rs2_frame_metadata_value = 23;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_HUE: rs2_frame_metadata_value = 24;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_GAMMA: rs2_frame_metadata_value = 25;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_MANUAL_WHITE_BALANCE:
    rs2_frame_metadata_value = 26;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_POWER_LINE_FREQUENCY:
    rs2_frame_metadata_value = 27;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_LOW_LIGHT_COMPENSATION:
    rs2_frame_metadata_value = 28;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_FRAME_EMITTER_MODE: rs2_frame_metadata_value =
    29;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_FRAME_LED_POWER: rs2_frame_metadata_value =
    30;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_RAW_FRAME_SIZE: rs2_frame_metadata_value = 31;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_COUNT: rs2_frame_metadata_value = 32;
pub type rs2_frame_metadata_value = u32;
extern "C" {
    pub fn rs2_frame_metadata_to_string(
        metadata: rs2_frame_metadata_value,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_frame_metadata_value_to_string(
        metadata: rs2_frame_metadata_value,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_get_frame_metadata(
        frame: *const rs2_frame,
        frame_metadata: rs2_frame_metadata_value,
        error: *mut *mut rs2_error,
    ) -> rs2_metadata_type;
}
extern "C" {
    pub fn rs2_supports_frame_metadata(
        frame: *const rs2_frame,
        frame_metadata: rs2_frame_metadata_value,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_get_frame_timestamp_domain(
        frameset: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> rs2_timestamp_domain;
}
extern "C" {
    pub fn rs2_get_frame_timestamp(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> rs2_time_t;
}
extern "C" {
    pub fn rs2_get_frame_sensor(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_sensor;
}
extern "C" {
    pub fn rs2_get_frame_number(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn rs2_get_frame_data_size(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_get_frame_data(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn rs2_get_frame_width(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_get_frame_height(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_get_frame_stride_in_bytes(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_get_frame_bits_per_pixel(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_frame_add_ref(frame: *mut rs2_frame, error: *mut *mut rs2_error);
}
extern "C" {
    pub fn rs2_release_frame(frame: *mut rs2_frame);
}
extern "C" {
    pub fn rs2_keep_frame(frame: *mut rs2_frame);
}
extern "C" {
    pub fn rs2_get_frame_vertices(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_vertex;
}
extern "C" {
    pub fn rs2_export_to_ply(
        frame: *const rs2_frame,
        fname: *const ::std::os::raw::c_char,
        texture: *mut rs2_frame,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_get_frame_texture_coordinates(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pixel;
}
extern "C" {
    pub fn rs2_get_frame_points_count(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_get_frame_stream_profile(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> *const rs2_stream_profile;
}
extern "C" {
    pub fn rs2_is_frame_extendable_to(
        frame: *const rs2_frame,
        extension_type: rs2_extension,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_allocate_synthetic_video_frame(
        source: *mut rs2_source,
        new_stream: *const rs2_stream_profile,
        original: *mut rs2_frame,
        new_bpp: ::std::os::raw::c_int,
        new_width: ::std::os::raw::c_int,
        new_height: ::std::os::raw::c_int,
        new_stride: ::std::os::raw::c_int,
        frame_type: rs2_extension,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_frame;
}
extern "C" {
    pub fn rs2_allocate_synthetic_motion_frame(
        source: *mut rs2_source,
        new_stream: *const rs2_stream_profile,
        original: *mut rs2_frame,
        frame_type: rs2_extension,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_frame;
}
extern "C" {
    pub fn rs2_allocate_points(
        source: *mut rs2_source,
        new_stream: *const rs2_stream_profile,
        original: *mut rs2_frame,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_frame;
}
extern "C" {
    pub fn rs2_allocate_composite_frame(
        source: *mut rs2_source,
        frames: *mut *mut rs2_frame,
        count: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_frame;
}
extern "C" {
    pub fn rs2_extract_frame(
        composite: *mut rs2_frame,
        index: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_frame;
}
extern "C" {
    pub fn rs2_embedded_frames_count(
        composite: *mut rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_synthetic_frame_ready(
        source: *mut rs2_source,
        frame: *mut rs2_frame,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_pose_frame_get_pose_data(
        frame: *const rs2_frame,
        pose: *mut rs2_pose,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_create_context(
        api_version: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_context;
}
extern "C" {
    pub fn rs2_delete_context(context: *mut rs2_context);
}
extern "C" {
    pub fn rs2_set_devices_changed_callback_cpp(
        context: *mut rs2_context,
        callback: *mut rs2_devices_changed_callback,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_set_devices_changed_callback(
        context: *const rs2_context,
        callback: rs2_devices_changed_callback_ptr,
        user: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_context_add_device(
        ctx: *mut rs2_context,
        file: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device;
}
extern "C" {
    pub fn rs2_context_add_software_device(
        ctx: *mut rs2_context,
        dev: *mut rs2_device,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_context_remove_device(
        ctx: *mut rs2_context,
        file: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_context_unload_tracking_module(ctx: *mut rs2_context, error: *mut *mut rs2_error);
}
extern "C" {
    pub fn rs2_query_devices(
        context: *const rs2_context,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device_list;
}
extern "C" {
    pub fn rs2_query_devices_ex(
        context: *const rs2_context,
        product_mask: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device_list;
}
extern "C" {
    pub fn rs2_create_device_hub(
        context: *const rs2_context,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device_hub;
}
extern "C" {
    pub fn rs2_delete_device_hub(hub: *const rs2_device_hub);
}
extern "C" {
    pub fn rs2_device_hub_wait_for_device(
        hub: *const rs2_device_hub,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device;
}
extern "C" {
    pub fn rs2_device_hub_is_device_connected(
        hub: *const rs2_device_hub,
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_get_device_count(
        info_list: *const rs2_device_list,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_delete_device_list(info_list: *mut rs2_device_list);
}
extern "C" {
    pub fn rs2_device_list_contains(
        info_list: *const rs2_device_list,
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_create_device(
        info_list: *const rs2_device_list,
        index: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device;
}
extern "C" {
    pub fn rs2_delete_device(device: *mut rs2_device);
}
extern "C" {
    pub fn rs2_get_device_info(
        device: *const rs2_device,
        info: rs2_camera_info,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_supports_device_info(
        device: *const rs2_device,
        info: rs2_camera_info,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_hardware_reset(device: *const rs2_device, error: *mut *mut rs2_error);
}
extern "C" {
    pub fn rs2_send_and_receive_raw_data(
        device: *mut rs2_device,
        raw_data_to_send: *mut ::std::os::raw::c_void,
        size_of_raw_data_to_send: ::std::os::raw::c_uint,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    pub fn rs2_is_device_extendable_to(
        device: *const rs2_device,
        extension: rs2_extension,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_query_sensors(
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_sensor_list;
}
extern "C" {
    pub fn rs2_loopback_enable(
        device: *const rs2_device,
        from_file: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_loopback_disable(device: *const rs2_device, error: *mut *mut rs2_error);
}
extern "C" {
    pub fn rs2_loopback_is_enabled(
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_connect_tm2_controller(
        device: *const rs2_device,
        mac_addr: *const ::std::os::raw::c_uchar,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_disconnect_tm2_controller(
        device: *const rs2_device,
        id: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_reset_to_factory_calibration(device: *const rs2_device, e: *mut *mut rs2_error);
}
extern "C" {
    pub fn rs2_write_calibration(device: *const rs2_device, e: *mut *mut rs2_error);
}
extern "C" {
    pub fn rs2_update_firmware_cpp(
        device: *const rs2_device,
        fw_image: *const ::std::os::raw::c_void,
        fw_image_size: ::std::os::raw::c_int,
        callback: *mut rs2_update_progress_callback,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_update_firmware(
        device: *const rs2_device,
        fw_image: *const ::std::os::raw::c_void,
        fw_image_size: ::std::os::raw::c_int,
        callback: rs2_update_progress_callback_ptr,
        client_data: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_create_flash_backup_cpp(
        device: *const rs2_device,
        callback: *mut rs2_update_progress_callback,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    pub fn rs2_create_flash_backup(
        device: *const rs2_device,
        callback: rs2_update_progress_callback_ptr,
        client_data: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    pub fn rs2_update_firmware_unsigned_cpp(
        device: *const rs2_device,
        fw_image: *const ::std::os::raw::c_void,
        fw_image_size: ::std::os::raw::c_int,
        callback: *mut rs2_update_progress_callback,
        update_mode: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_update_firmware_unsigned(
        device: *const rs2_device,
        fw_image: *const ::std::os::raw::c_void,
        fw_image_size: ::std::os::raw::c_int,
        callback: rs2_update_progress_callback_ptr,
        client_data: *mut ::std::os::raw::c_void,
        update_mode: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_enter_update_state(device: *const rs2_device, error: *mut *mut rs2_error);
}
extern "C" {
    pub fn rs2_run_on_chip_calibration_cpp(
        device: *mut rs2_device,
        json_content: *const ::std::os::raw::c_void,
        content_size: ::std::os::raw::c_int,
        health: *mut f32,
        progress_callback: *mut rs2_update_progress_callback,
        timeout_ms: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    pub fn rs2_run_on_chip_calibration(
        device: *mut rs2_device,
        json_content: *const ::std::os::raw::c_void,
        content_size: ::std::os::raw::c_int,
        health: *mut f32,
        callback: rs2_update_progress_callback_ptr,
        client_data: *mut ::std::os::raw::c_void,
        timeout_ms: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    pub fn rs2_run_tare_calibration_cpp(
        dev: *mut rs2_device,
        ground_truth_mm: f32,
        json_content: *const ::std::os::raw::c_void,
        content_size: ::std::os::raw::c_int,
        progress_callback: *mut rs2_update_progress_callback,
        timeout_ms: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    pub fn rs2_run_tare_calibration(
        dev: *mut rs2_device,
        ground_truth_mm: f32,
        json_content: *const ::std::os::raw::c_void,
        content_size: ::std::os::raw::c_int,
        callback: rs2_update_progress_callback_ptr,
        client_data: *mut ::std::os::raw::c_void,
        timeout_ms: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    pub fn rs2_get_calibration_table(
        dev: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    pub fn rs2_set_calibration_table(
        device: *const rs2_device,
        calibration: *const ::std::os::raw::c_void,
        calibration_size: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
pub const rs2_option_RS2_OPTION_BACKLIGHT_COMPENSATION: rs2_option = 0;
pub const rs2_option_RS2_OPTION_BRIGHTNESS: rs2_option = 1;
pub const rs2_option_RS2_OPTION_CONTRAST: rs2_option = 2;
pub const rs2_option_RS2_OPTION_EXPOSURE: rs2_option = 3;
pub const rs2_option_RS2_OPTION_GAIN: rs2_option = 4;
pub const rs2_option_RS2_OPTION_GAMMA: rs2_option = 5;
pub const rs2_option_RS2_OPTION_HUE: rs2_option = 6;
pub const rs2_option_RS2_OPTION_SATURATION: rs2_option = 7;
pub const rs2_option_RS2_OPTION_SHARPNESS: rs2_option = 8;
pub const rs2_option_RS2_OPTION_WHITE_BALANCE: rs2_option = 9;
pub const rs2_option_RS2_OPTION_ENABLE_AUTO_EXPOSURE: rs2_option = 10;
pub const rs2_option_RS2_OPTION_ENABLE_AUTO_WHITE_BALANCE: rs2_option = 11;
pub const rs2_option_RS2_OPTION_VISUAL_PRESET: rs2_option = 12;
pub const rs2_option_RS2_OPTION_LASER_POWER: rs2_option = 13;
pub const rs2_option_RS2_OPTION_ACCURACY: rs2_option = 14;
pub const rs2_option_RS2_OPTION_MOTION_RANGE: rs2_option = 15;
pub const rs2_option_RS2_OPTION_FILTER_OPTION: rs2_option = 16;
pub const rs2_option_RS2_OPTION_CONFIDENCE_THRESHOLD: rs2_option = 17;
pub const rs2_option_RS2_OPTION_EMITTER_ENABLED: rs2_option = 18;
pub const rs2_option_RS2_OPTION_FRAMES_QUEUE_SIZE: rs2_option = 19;
pub const rs2_option_RS2_OPTION_TOTAL_FRAME_DROPS: rs2_option = 20;
pub const rs2_option_RS2_OPTION_AUTO_EXPOSURE_MODE: rs2_option = 21;
pub const rs2_option_RS2_OPTION_POWER_LINE_FREQUENCY: rs2_option = 22;
pub const rs2_option_RS2_OPTION_ASIC_TEMPERATURE: rs2_option = 23;
pub const rs2_option_RS2_OPTION_ERROR_POLLING_ENABLED: rs2_option = 24;
pub const rs2_option_RS2_OPTION_PROJECTOR_TEMPERATURE: rs2_option = 25;
pub const rs2_option_RS2_OPTION_OUTPUT_TRIGGER_ENABLED: rs2_option = 26;
pub const rs2_option_RS2_OPTION_MOTION_MODULE_TEMPERATURE: rs2_option = 27;
pub const rs2_option_RS2_OPTION_DEPTH_UNITS: rs2_option = 28;
pub const rs2_option_RS2_OPTION_ENABLE_MOTION_CORRECTION: rs2_option = 29;
pub const rs2_option_RS2_OPTION_AUTO_EXPOSURE_PRIORITY: rs2_option = 30;
pub const rs2_option_RS2_OPTION_COLOR_SCHEME: rs2_option = 31;
pub const rs2_option_RS2_OPTION_HISTOGRAM_EQUALIZATION_ENABLED: rs2_option = 32;
pub const rs2_option_RS2_OPTION_MIN_DISTANCE: rs2_option = 33;
pub const rs2_option_RS2_OPTION_MAX_DISTANCE: rs2_option = 34;
pub const rs2_option_RS2_OPTION_TEXTURE_SOURCE: rs2_option = 35;
pub const rs2_option_RS2_OPTION_FILTER_MAGNITUDE: rs2_option = 36;
pub const rs2_option_RS2_OPTION_FILTER_SMOOTH_ALPHA: rs2_option = 37;
pub const rs2_option_RS2_OPTION_FILTER_SMOOTH_DELTA: rs2_option = 38;
pub const rs2_option_RS2_OPTION_HOLES_FILL: rs2_option = 39;
pub const rs2_option_RS2_OPTION_STEREO_BASELINE: rs2_option = 40;
pub const rs2_option_RS2_OPTION_AUTO_EXPOSURE_CONVERGE_STEP: rs2_option = 41;
pub const rs2_option_RS2_OPTION_INTER_CAM_SYNC_MODE: rs2_option = 42;
pub const rs2_option_RS2_OPTION_STREAM_FILTER: rs2_option = 43;
pub const rs2_option_RS2_OPTION_STREAM_FORMAT_FILTER: rs2_option = 44;
pub const rs2_option_RS2_OPTION_STREAM_INDEX_FILTER: rs2_option = 45;
pub const rs2_option_RS2_OPTION_EMITTER_ON_OFF: rs2_option = 46;
pub const rs2_option_RS2_OPTION_ZERO_ORDER_POINT_X: rs2_option = 47;
pub const rs2_option_RS2_OPTION_ZERO_ORDER_POINT_Y: rs2_option = 48;
pub const rs2_option_RS2_OPTION_LLD_TEMPERATURE: rs2_option = 49;
pub const rs2_option_RS2_OPTION_MC_TEMPERATURE: rs2_option = 50;
pub const rs2_option_RS2_OPTION_MA_TEMPERATURE: rs2_option = 51;
pub const rs2_option_RS2_OPTION_HARDWARE_PRESET: rs2_option = 52;
pub const rs2_option_RS2_OPTION_GLOBAL_TIME_ENABLED: rs2_option = 53;
pub const rs2_option_RS2_OPTION_APD_TEMPERATURE: rs2_option = 54;
pub const rs2_option_RS2_OPTION_ENABLE_MAPPING: rs2_option = 55;
pub const rs2_option_RS2_OPTION_ENABLE_RELOCALIZATION: rs2_option = 56;
pub const rs2_option_RS2_OPTION_ENABLE_POSE_JUMPING: rs2_option = 57;
pub const rs2_option_RS2_OPTION_ENABLE_DYNAMIC_CALIBRATION: rs2_option = 58;
pub const rs2_option_RS2_OPTION_DEPTH_OFFSET: rs2_option = 59;
pub const rs2_option_RS2_OPTION_LED_POWER: rs2_option = 60;
pub const rs2_option_RS2_OPTION_ZERO_ORDER_ENABLED: rs2_option = 61;
pub const rs2_option_RS2_OPTION_ENABLE_MAP_PRESERVATION: rs2_option = 62;
pub const rs2_option_RS2_OPTION_COUNT: rs2_option = 63;
pub type rs2_option = u32;
extern "C" {
    pub fn rs2_option_to_string(option: rs2_option) -> *const ::std::os::raw::c_char;
}
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_SHORT_RANGE: rs2_sr300_visual_preset = 0;
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_LONG_RANGE: rs2_sr300_visual_preset = 1;
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_BACKGROUND_SEGMENTATION:
    rs2_sr300_visual_preset = 2;
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_GESTURE_RECOGNITION:
    rs2_sr300_visual_preset = 3;
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_OBJECT_SCANNING: rs2_sr300_visual_preset =
    4;
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_FACE_ANALYTICS: rs2_sr300_visual_preset =
    5;
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_FACE_LOGIN: rs2_sr300_visual_preset = 6;
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_GR_CURSOR: rs2_sr300_visual_preset = 7;
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_DEFAULT: rs2_sr300_visual_preset = 8;
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_MID_RANGE: rs2_sr300_visual_preset = 9;
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_IR_ONLY: rs2_sr300_visual_preset = 10;
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_COUNT: rs2_sr300_visual_preset = 11;
pub type rs2_sr300_visual_preset = u32;
extern "C" {
    pub fn rs2_sr300_visual_preset_to_string(
        preset: rs2_sr300_visual_preset,
    ) -> *const ::std::os::raw::c_char;
}
pub const rs2_rs400_visual_preset_RS2_RS400_VISUAL_PRESET_CUSTOM: rs2_rs400_visual_preset = 0;
pub const rs2_rs400_visual_preset_RS2_RS400_VISUAL_PRESET_DEFAULT: rs2_rs400_visual_preset = 1;
pub const rs2_rs400_visual_preset_RS2_RS400_VISUAL_PRESET_HAND: rs2_rs400_visual_preset = 2;
pub const rs2_rs400_visual_preset_RS2_RS400_VISUAL_PRESET_HIGH_ACCURACY: rs2_rs400_visual_preset =
    3;
pub const rs2_rs400_visual_preset_RS2_RS400_VISUAL_PRESET_HIGH_DENSITY: rs2_rs400_visual_preset = 4;
pub const rs2_rs400_visual_preset_RS2_RS400_VISUAL_PRESET_MEDIUM_DENSITY: rs2_rs400_visual_preset =
    5;
pub const rs2_rs400_visual_preset_RS2_RS400_VISUAL_PRESET_REMOVE_IR_PATTERN:
    rs2_rs400_visual_preset = 6;
pub const rs2_rs400_visual_preset_RS2_RS400_VISUAL_PRESET_COUNT: rs2_rs400_visual_preset = 7;
pub type rs2_rs400_visual_preset = u32;
extern "C" {
    pub fn rs2_rs400_visual_preset_to_string(
        preset: rs2_rs400_visual_preset,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_is_option_read_only(
        options: *const rs2_options,
        option: rs2_option,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_get_option(
        options: *const rs2_options,
        option: rs2_option,
        error: *mut *mut rs2_error,
    ) -> f32;
}
extern "C" {
    pub fn rs2_set_option(
        options: *const rs2_options,
        option: rs2_option,
        value: f32,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_get_options_list(
        options: *const rs2_options,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_options_list;
}
extern "C" {
    pub fn rs2_get_options_list_size(
        options: *const rs2_options_list,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_get_option_name(
        options: *const rs2_options,
        option: rs2_option,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_get_option_from_list(
        options: *const rs2_options_list,
        i: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> rs2_option;
}
extern "C" {
    pub fn rs2_delete_options_list(list: *mut rs2_options_list);
}
extern "C" {
    pub fn rs2_supports_option(
        options: *const rs2_options,
        option: rs2_option,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_get_option_range(
        sensor: *const rs2_options,
        option: rs2_option,
        min: *mut f32,
        max: *mut f32,
        step: *mut f32,
        def: *mut f32,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_get_option_description(
        options: *const rs2_options,
        option: rs2_option,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_get_option_value_description(
        options: *const rs2_options,
        option: rs2_option,
        value: f32,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_create_colorizer(error: *mut *mut rs2_error) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_create_sync_processing_block(
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_create_pointcloud(error: *mut *mut rs2_error) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_create_yuy_decoder(error: *mut *mut rs2_error) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_create_threshold(error: *mut *mut rs2_error) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_create_units_transform(error: *mut *mut rs2_error) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_create_processing_block(
        proc_: *mut rs2_frame_processor_callback,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_create_processing_block_fptr(
        proc_: rs2_frame_processor_callback_ptr,
        context: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_processing_block_register_simple_option(
        block: *mut rs2_processing_block,
        option_id: rs2_option,
        min: f32,
        max: f32,
        step: f32,
        def: f32,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_start_processing(
        block: *mut rs2_processing_block,
        on_frame: *mut rs2_frame_callback,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_start_processing_fptr(
        block: *mut rs2_processing_block,
        on_frame: rs2_frame_callback_ptr,
        user: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_start_processing_queue(
        block: *mut rs2_processing_block,
        queue: *mut rs2_frame_queue,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_process_frame(
        block: *mut rs2_processing_block,
        frame: *mut rs2_frame,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_delete_processing_block(block: *mut rs2_processing_block);
}
extern "C" {
    pub fn rs2_create_frame_queue(
        capacity: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_frame_queue;
}
extern "C" {
    pub fn rs2_delete_frame_queue(queue: *mut rs2_frame_queue);
}
extern "C" {
    pub fn rs2_wait_for_frame(
        queue: *mut rs2_frame_queue,
        timeout_ms: ::std::os::raw::c_uint,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_frame;
}
extern "C" {
    pub fn rs2_poll_for_frame(
        queue: *mut rs2_frame_queue,
        output_frame: *mut *mut rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_try_wait_for_frame(
        queue: *mut rs2_frame_queue,
        timeout_ms: ::std::os::raw::c_uint,
        output_frame: *mut *mut rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_enqueue_frame(frame: *mut rs2_frame, queue: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn rs2_create_align(
        align_to: rs2_stream,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_create_decimation_filter_block(
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_create_temporal_filter_block(
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_create_spatial_filter_block(error: *mut *mut rs2_error)
        -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_create_disparity_transform_block(
        transform_to_disparity: ::std::os::raw::c_uchar,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_create_hole_filling_filter_block(
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_create_rates_printer_block(error: *mut *mut rs2_error) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_create_zero_order_invalidation_block(
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_create_huffman_depth_decompress_block(
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    pub fn rs2_get_processing_block_info(
        block: *const rs2_processing_block,
        info: rs2_camera_info,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_supports_processing_block_info(
        block: *const rs2_processing_block,
        info: rs2_camera_info,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_is_processing_block_extendable_to(
        block: *const rs2_processing_block,
        extension_type: rs2_extension,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
pub const rs2_playback_status_RS2_PLAYBACK_STATUS_UNKNOWN: rs2_playback_status = 0;
pub const rs2_playback_status_RS2_PLAYBACK_STATUS_PLAYING: rs2_playback_status = 1;
pub const rs2_playback_status_RS2_PLAYBACK_STATUS_PAUSED: rs2_playback_status = 2;
pub const rs2_playback_status_RS2_PLAYBACK_STATUS_STOPPED: rs2_playback_status = 3;
pub const rs2_playback_status_RS2_PLAYBACK_STATUS_COUNT: rs2_playback_status = 4;
pub type rs2_playback_status = u32;
extern "C" {
    pub fn rs2_playback_status_to_string(
        status: rs2_playback_status,
    ) -> *const ::std::os::raw::c_char;
}
pub type rs2_playback_status_changed_callback_ptr =
    ::std::option::Option<unsafe extern "C" fn(arg1: rs2_playback_status)>;
extern "C" {
    pub fn rs2_create_record_device(
        device: *const rs2_device,
        file: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device;
}
extern "C" {
    pub fn rs2_create_record_device_ex(
        device: *const rs2_device,
        file: *const ::std::os::raw::c_char,
        compression_enabled: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device;
}
extern "C" {
    pub fn rs2_record_device_pause(device: *const rs2_device, error: *mut *mut rs2_error);
}
extern "C" {
    pub fn rs2_record_device_resume(device: *const rs2_device, error: *mut *mut rs2_error);
}
extern "C" {
    pub fn rs2_record_device_filename(
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_create_playback_device(
        file: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device;
}
extern "C" {
    pub fn rs2_playback_device_get_file_path(
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_playback_get_duration(
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn rs2_playback_seek(
        device: *const rs2_device,
        time: ::std::os::raw::c_longlong,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_playback_get_position(
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn rs2_playback_device_resume(device: *const rs2_device, error: *mut *mut rs2_error);
}
extern "C" {
    pub fn rs2_playback_device_pause(device: *const rs2_device, error: *mut *mut rs2_error);
}
extern "C" {
    pub fn rs2_playback_device_set_real_time(
        device: *const rs2_device,
        real_time: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_playback_device_is_real_time(
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_playback_device_set_status_changed_callback(
        device: *const rs2_device,
        callback: *mut rs2_playback_status_changed_callback,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_playback_device_get_current_status(
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> rs2_playback_status;
}
extern "C" {
    pub fn rs2_playback_device_set_playback_speed(
        device: *const rs2_device,
        speed: f32,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_playback_device_stop(device: *const rs2_device, error: *mut *mut rs2_error);
}
extern "C" {
    pub fn rs2_get_raw_data_size(
        buffer: *const rs2_raw_data_buffer,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_delete_raw_data(buffer: *const rs2_raw_data_buffer);
}
extern "C" {
    pub fn rs2_get_raw_data(
        buffer: *const rs2_raw_data_buffer,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn rs2_get_api_version(error: *mut *mut rs2_error) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_log_to_console(min_severity: rs2_log_severity, error: *mut *mut rs2_error);
}
extern "C" {
    pub fn rs2_log_to_file(
        min_severity: rs2_log_severity,
        file_path: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_log(
        severity: rs2_log_severity,
        message: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    pub fn rs2_depth_frame_get_distance(
        frame_ref: *const rs2_frame,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> f32;
}
extern "C" {
    pub fn rs2_get_time(error: *mut *mut rs2_error) -> rs2_time_t;
}
pub type __uint16_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn _rs2_project_point_to_pixel(
        pixel: *mut f32,
        intrin: *const rs2_intrinsics,
        point: *const f32,
    );
}
extern "C" {
    pub fn _rs2_deproject_pixel_to_point(
        point: *mut f32,
        intrin: *const rs2_intrinsics,
        pixel: *const f32,
        depth: f32,
    );
}
extern "C" {
    pub fn _rs2_transform_point_to_point(
        to_point: *mut f32,
        extrin: *const rs2_extrinsics,
        from_point: *const f32,
    );
}
extern "C" {
    pub fn _rs2_fov(intrin: *const rs2_intrinsics, to_fov: *mut f32);
}
extern "C" {
    pub fn _rs2_project_color_pixel_to_depth_pixel(
        to_pixel: *mut f32,
        data: *const u16,
        depth_scale: f32,
        depth_min: f32,
        depth_max: f32,
        depth_intrin: *const rs2_intrinsics,
        color_intrin: *const rs2_intrinsics,
        color_to_depth: *const rs2_extrinsics,
        depth_to_color: *const rs2_extrinsics,
        from_pixel: *const f32,
    );
}
extern "C" {
    /// Create a config instance
    /// The config allows pipeline users to request filters for the pipeline streams and device selection and configuration.
    /// This is an optional step in pipeline creation, as the pipeline resolves its streaming device internally.
    /// Config provides its users a way to set the filters and test if there is no conflict with the pipeline requirements
    /// from the device. It also allows the user to find a matching device for the config filters and the pipeline, in order to
    /// select a device explicitly, and modify its controls before streaming starts.
    ///
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return rs2_config*  A pointer to a new config instance
    pub fn rs2_create_config(error: *mut *mut rs2_error) -> *mut rs2_config;
}
extern "C" {
    /// Deletes an instance of a config
    ///
    /// \param[in] config    A pointer to an instance of a config
    pub fn rs2_delete_config(config: *mut rs2_config);
}
extern "C" {
    /// Enable a device stream explicitly, with selected stream parameters.
    /// The method allows the application to request a stream with specific configuration. If no stream is explicitly enabled, the pipeline
    /// configures the device and its streams according to the attached computer vision modules and processing blocks requirements, or
    /// default configuration for the first available device.
    /// The application can configure any of the input stream parameters according to its requirement, or set to 0 for don't care value.
    /// The config accumulates the application calls for enable configuration methods, until the configuration is applied. Multiple enable
    /// stream calls for the same stream with conflicting parameters override each other, and the last call is maintained.
    /// Upon calling \c resolve(), the config checks for conflicts between the application configuration requests and the attached computer
    /// vision modules and processing blocks requirements, and fails if conflicts are found. Before \c resolve() is called, no conflict
    /// check is done.
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[in] stream    Stream type to be enabled
    /// \param[in] index     Stream index, used for multiple streams of the same type. -1 indicates any.
    /// \param[in] width     Stream image width - for images streams. 0 indicates any.
    /// \param[in] height    Stream image height - for images streams. 0 indicates any.
    /// \param[in] format    Stream data format - pixel format for images streams, of data type for other streams. RS2_FORMAT_ANY indicates any.
    /// \param[in] framerate Stream frames per second. 0 indicates any.
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_enable_stream(
        config: *mut rs2_config,
        stream: rs2_stream,
        index: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        format: rs2_format,
        framerate: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Enable all device streams explicitly.
    /// The conditions and behavior of this method are similar to those of \c enable_stream().
    /// This filter enables all raw streams of the selected device. The device is either selected explicitly by the application,
    /// or by the pipeline requirements or default. The list of streams is device dependent.
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_enable_all_stream(config: *mut rs2_config, error: *mut *mut rs2_error);
}
extern "C" {
    /// Select a specific device explicitly by its serial number, to be used by the pipeline.
    /// The conditions and behavior of this method are similar to those of \c enable_stream().
    /// This method is required if the application needs to set device or sensor settings prior to pipeline streaming, to enforce
    /// the pipeline to use the configured device.
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[in] serial device serial number, as returned by RS2_CAMERA_INFO_SERIAL_NUMBER
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_enable_device(
        config: *mut rs2_config,
        serial: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Select a recorded device from a file, to be used by the pipeline through playback.
    /// The device available streams are as recorded to the file, and \c resolve() considers only this device and configuration
    /// as available.
    /// This request cannot be used if enable_record_to_file() is called for the current config, and vise versa
    /// By default, playback is repeated once the file ends. To control this, see 'rs2_config_enable_device_from_file_repeat_option'.
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[in] file      The playback file of the device
    /// \param[out] error    if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_enable_device_from_file(
        config: *mut rs2_config,
        file: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Select a recorded device from a file, to be used by the pipeline through playback.
    /// The device available streams are as recorded to the file, and \c resolve() considers only this device and configuration
    /// as available.
    /// This request cannot be used if enable_record_to_file() is called for the current config, and vise versa
    ///
    /// \param[in] config           A pointer to an instance of a config
    /// \param[in] file             The playback file of the device
    /// \param[in] repeat_playback  if true, when file ends the playback starts again, in an infinite loop;
    ///if false, when file ends playback does not start again, and should by stopped manually by the user.
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_enable_device_from_file_repeat_option(
        config: *mut rs2_config,
        file: *const ::std::os::raw::c_char,
        repeat_playback: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Requires that the resolved device would be recorded to file
    /// This request cannot be used if enable_device_from_file() is called for the current config, and vise versa
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[in] file      The desired file for the output record
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_enable_record_to_file(
        config: *mut rs2_config,
        file: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Disable a device stream explicitly, to remove any requests on this stream type.
    /// The stream can still be enabled due to pipeline computer vision module request. This call removes any filter on the
    /// stream configuration.
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[in] stream    Stream type, for which the filters are cleared
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_disable_stream(
        config: *mut rs2_config,
        stream: rs2_stream,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Disable a device stream explicitly, to remove any requests on this stream profile.
    /// The stream can still be enabled due to pipeline computer vision module request. This call removes any filter on the
    /// stream configuration.
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[in] stream    Stream type, for which the filters are cleared
    /// \param[in] index     Stream index, for which the filters are cleared
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_disable_indexed_stream(
        config: *mut rs2_config,
        stream: rs2_stream,
        index: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Disable all device stream explicitly, to remove any requests on the streams profiles.
    /// The streams can still be enabled due to pipeline computer vision module request. This call removes any filter on the
    /// streams configuration.
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_disable_all_streams(config: *mut rs2_config, error: *mut *mut rs2_error);
}
extern "C" {
    /// Resolve the configuration filters, to find a matching device and streams profiles.
    /// The method resolves the user configuration filters for the device and streams, and combines them with the requirements of
    /// the computer vision modules and processing blocks attached to the pipeline. If there are no conflicts of requests, it looks
    /// for an available device, which can satisfy all requests, and selects the first matching streams configuration. In the absence
    /// of any request, the rs2::config selects the first available device and the first color and depth streams configuration.
    /// The pipeline profile selection during \c start() follows the same method. Thus, the selected profile is the same, if no
    /// change occurs to the available devices occurs.
    /// Resolving the pipeline configuration provides the application access to the pipeline selected device for advanced control.
    /// The returned configuration is not applied to the device, so the application doesn't own the device sensors. However, the
    /// application can call \c enable_device(), to enforce the device returned by this method is selected by pipeline \c start(),
    /// and configure the device and sensors options or extensions before streaming starts.
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[in] pipe  The pipeline for which the selected filters are applied
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return       A matching device and streams profile, which satisfies the filters and pipeline requests.
    pub fn rs2_config_resolve(
        config: *mut rs2_config,
        pipe: *mut rs2_pipeline,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline_profile;
}
extern "C" {
    /// Check if the config can resolve the configuration filters, to find a matching device and streams profiles.
    /// The resolution conditions are as described in \c resolve().
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[in] pipe  The pipeline for which the selected filters are applied
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return       True if a valid profile selection exists, false if no selection can be found under the config filters and the available devices.
    pub fn rs2_config_can_resolve(
        config: *mut rs2_config,
        pipe: *mut rs2_pipeline,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Create a pipeline instance
    /// The pipeline simplifies the user interaction with the device and computer vision processing modules.
    /// The class abstracts the camera configuration and streaming, and the vision modules triggering and threading.
    /// It lets the application focus on the computer vision output of the modules, or the device output data.
    /// The pipeline can manage computer vision modules, which are implemented as a processing blocks.
    /// The pipeline is the consumer of the processing block interface, while the application consumes the
    /// computer vision interface.
    /// \param[in]  ctx    context
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_pipeline(
        ctx: *mut rs2_context,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline;
}
extern "C" {
    /// Stop the pipeline streaming.
    /// The pipeline stops delivering samples to the attached computer vision modules and processing blocks, stops the device streaming
    /// and releases the device resources used by the pipeline. It is the application's responsibility to release any frame reference it owns.
    /// The method takes effect only after \c start() was called, otherwise an exception is raised.
    /// \param[in] pipe  pipeline
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_pipeline_stop(pipe: *mut rs2_pipeline, error: *mut *mut rs2_error);
}
extern "C" {
    /// Wait until a new set of frames becomes available.
    /// The frames set includes time-synchronized frames of each enabled stream in the pipeline.
    /// The method blocks the calling thread, and fetches the latest unread frames set.
    /// Device frames, which were produced while the function wasn't called, are dropped. To avoid frame drops, this method should be called
    /// as fast as the device frame rate.
    /// The application can maintain the frames handles to defer processing. However, if the application maintains too long history, the device
    /// may lack memory resources to produce new frames, and the following call to this method shall fail to retrieve new frames, until resources
    /// are retained.
    /// \param[in] pipe the pipeline
    /// \param[in] timeout_ms   Max time in milliseconds to wait until an exception will be thrown
    /// \param[out] error         if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return Set of coherent frames
    pub fn rs2_pipeline_wait_for_frames(
        pipe: *mut rs2_pipeline,
        timeout_ms: ::std::os::raw::c_uint,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_frame;
}
extern "C" {
    /// Check if a new set of frames is available and retrieve the latest undelivered set.
    /// The frames set includes time-synchronized frames of each enabled stream in the pipeline.
    /// The method returns without blocking the calling thread, with status of new frames available or not. If available, it fetches the
    /// latest frames set.
    /// Device frames, which were produced while the function wasn't called, are dropped. To avoid frame drops, this method should be called
    /// as fast as the device frame rate.
    /// The application can maintain the frames handles to defer processing. However, if the application maintains too long history, the device
    /// may lack memory resources to produce new frames, and the following calls to this method shall return no new frames, until resources are
    /// retained.
    /// \param[in] pipe the pipeline
    /// \param[out] output_frame frame handle to be released using rs2_release_frame
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return true if new frame was stored to output_frame
    pub fn rs2_pipeline_poll_for_frames(
        pipe: *mut rs2_pipeline,
        output_frame: *mut *mut rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Wait until a new set of frames becomes available.
    /// The frames set includes time-synchronized frames of each enabled stream in the pipeline.
    /// The method blocks the calling thread, and fetches the latest unread frames set.
    /// Device frames, which were produced while the function wasn't called, are dropped. To avoid frame drops, this method should be called
    /// as fast as the device frame rate.
    /// The application can maintain the frames handles to defer processing. However, if the application maintains too long history, the device
    /// may lack memory resources to produce new frames, and the following call to this method shall fail to retrieve new frames, until resources
    /// are retained.
    /// \param[in] pipe           the pipeline
    /// \param[in] timeout_ms     max time in milliseconds to wait until a frame becomes available
    /// \param[out] output_frame  frame handle to be released using rs2_release_frame
    /// \param[out] error         if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return true if new frame was stored to output_frame
    pub fn rs2_pipeline_try_wait_for_frames(
        pipe: *mut rs2_pipeline,
        output_frame: *mut *mut rs2_frame,
        timeout_ms: ::std::os::raw::c_uint,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Delete a pipeline instance.
    /// Upon destruction, the pipeline will implicitly stop itself
    /// \param[in] pipe to delete
    pub fn rs2_delete_pipeline(pipe: *mut rs2_pipeline);
}
extern "C" {
    /// Start the pipeline streaming with its default configuration.
    /// The pipeline streaming loop captures samples from the device, and delivers them to the attached computer vision modules
    /// and processing blocks, according to each module requirements and threading model.
    /// During the loop execution, the application can access the camera streams by calling \c wait_for_frames() or \c poll_for_frames().
    /// The streaming loop runs until the pipeline is stopped.
    /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
    ///
    /// \param[in] pipe    a pointer to an instance of the pipeline
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
    pub fn rs2_pipeline_start(
        pipe: *mut rs2_pipeline,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline_profile;
}
extern "C" {
    /// Start the pipeline streaming according to the configuraion.
    /// The pipeline streaming loop captures samples from the device, and delivers them to the attached computer vision modules
    /// and processing blocks, according to each module requirements and threading model.
    /// During the loop execution, the application can access the camera streams by calling \c wait_for_frames() or \c poll_for_frames().
    /// The streaming loop runs until the pipeline is stopped.
    /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
    /// The pipeline selects and activates the device upon start, according to configuration or a default configuration.
    /// When the rs2::config is provided to the method, the pipeline tries to activate the config \c resolve() result. If the application
    /// requests are conflicting with pipeline computer vision modules or no matching device is available on the platform, the method fails.
    /// Available configurations and devices may change between config \c resolve() call and pipeline start, in case devices are connected
    /// or disconnected, or another application acquires ownership of a device.
    ///
    /// \param[in] pipe    a pointer to an instance of the pipeline
    /// \param[in] config   A rs2::config with requested filters on the pipeline configuration. By default no filters are applied.
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
    pub fn rs2_pipeline_start_with_config(
        pipe: *mut rs2_pipeline,
        config: *mut rs2_config,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline_profile;
}
extern "C" {
    /// Start the pipeline streaming with its default configuration.
    /// The pipeline captures samples from the device, and delivers them to the through the provided frame callback.
    /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
    /// When starting the pipeline with a callback both \c wait_for_frames() or \c poll_for_frames() will throw exception.
    ///
    /// \param[in] pipe     A pointer to an instance of the pipeline
    /// \param[in] on_frame function pointer to register as per-frame callback
    /// \param[in] user auxiliary  data the user wishes to receive together with every frame callback
    /// \param[out] error   If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
    pub fn rs2_pipeline_start_with_callback(
        pipe: *mut rs2_pipeline,
        on_frame: rs2_frame_callback_ptr,
        user: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline_profile;
}
extern "C" {
    /// Start the pipeline streaming with its default configuration.
    /// The pipeline captures samples from the device, and delivers them to the through the provided frame callback.
    /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
    /// When starting the pipeline with a callback both \c wait_for_frames() or \c poll_for_frames() will throw exception.
    ///
    /// \param[in] pipe     A pointer to an instance of the pipeline
    /// \param[in] callback callback object created from c++ application. ownership over the callback object is moved into the relevant streaming lock
    /// \param[out] error   If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
    pub fn rs2_pipeline_start_with_callback_cpp(
        pipe: *mut rs2_pipeline,
        callback: *mut rs2_frame_callback,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline_profile;
}
extern "C" {
    /// Start the pipeline streaming according to the configuraion.
    /// The pipeline captures samples from the device, and delivers them to the through the provided frame callback.
    /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
    /// When starting the pipeline with a callback both \c wait_for_frames() or \c poll_for_frames() will throw exception.
    /// The pipeline selects and activates the device upon start, according to configuration or a default configuration.
    /// When the rs2::config is provided to the method, the pipeline tries to activate the config \c resolve() result. If the application
    /// requests are conflicting with pipeline computer vision modules or no matching device is available on the platform, the method fails.
    /// Available configurations and devices may change between config \c resolve() call and pipeline start, in case devices are connected
    /// or disconnected, or another application acquires ownership of a device.
    ///
    /// \param[in] pipe     A pointer to an instance of the pipeline
    /// \param[in] config   A rs2::config with requested filters on the pipeline configuration. By default no filters are applied.
    /// \param[in] on_frame function pointer to register as per-frame callback
    /// \param[in] user auxiliary  data the user wishes to receive together with every frame callback
    /// \param[out] error   If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
    pub fn rs2_pipeline_start_with_config_and_callback(
        pipe: *mut rs2_pipeline,
        config: *mut rs2_config,
        on_frame: rs2_frame_callback_ptr,
        user: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline_profile;
}
extern "C" {
    /// Start the pipeline streaming according to the configuraion.
    /// The pipeline captures samples from the device, and delivers them to the through the provided frame callback.
    /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
    /// When starting the pipeline with a callback both \c wait_for_frames() or \c poll_for_frames() will throw exception.
    /// The pipeline selects and activates the device upon start, according to configuration or a default configuration.
    /// When the rs2::config is provided to the method, the pipeline tries to activate the config \c resolve() result. If the application
    /// requests are conflicting with pipeline computer vision modules or no matching device is available on the platform, the method fails.
    /// Available configurations and devices may change between config \c resolve() call and pipeline start, in case devices are connected
    /// or disconnected, or another application acquires ownership of a device.
    ///
    /// \param[in] pipe     A pointer to an instance of the pipeline
    /// \param[in] config   A rs2::config with requested filters on the pipeline configuration. By default no filters are applied.
    /// \param[in] callback callback object created from c++ application. ownership over the callback object is moved into the relevant streaming lock
    /// \param[out] error   If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
    pub fn rs2_pipeline_start_with_config_and_callback_cpp(
        pipe: *mut rs2_pipeline,
        config: *mut rs2_config,
        callback: *mut rs2_frame_callback,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline_profile;
}
extern "C" {
    /// Return the active device and streams profiles, used by the pipeline.
    /// The pipeline streams profiles are selected during \c start(). The method returns a valid result only when the pipeline is active -
    /// between calls to \c start() and \c stop().
    /// After \c stop() is called, the pipeline doesn't own the device, thus, the pipeline selected device may change in subsequent activations.
    ///
    /// \param[in] pipe    a pointer to an instance of the pipeline
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return  The actual pipeline device and streams profile, which was successfully configured to the streaming device on start.
    pub fn rs2_pipeline_get_active_profile(
        pipe: *mut rs2_pipeline,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline_profile;
}
extern "C" {
    /// Retrieve the device used by the pipeline.
    /// The device class provides the application access to control camera additional settings -
    /// get device information, sensor options information, options value query and set, sensor specific extensions.
    /// Since the pipeline controls the device streams configuration, activation state and frames reading, calling
    /// the device API functions, which execute those operations, results in unexpected behavior.
    /// The pipeline streaming device is selected during pipeline \c start(). Devices of profiles, which are not returned by
    /// pipeline \c start() or \c get_active_profile(), are not guaranteed to be used by the pipeline.
    ///
    /// \param[in] profile    A pointer to an instance of a pipeline profile
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return rs2_device* The pipeline selected device
    pub fn rs2_pipeline_profile_get_device(
        profile: *mut rs2_pipeline_profile,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device;
}
extern "C" {
    /// Return the selected streams profiles, which are enabled in this profile.
    ///
    /// \param[in] profile    A pointer to an instance of a pipeline profile
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return   list of stream profiles
    pub fn rs2_pipeline_profile_get_streams(
        profile: *mut rs2_pipeline_profile,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_stream_profile_list;
}
extern "C" {
    /// Deletes an instance of a pipeline profile
    ///
    /// \param[in] profile    A pointer to an instance of a pipeline profile
    pub fn rs2_delete_pipeline_profile(profile: *mut rs2_pipeline_profile);
}
