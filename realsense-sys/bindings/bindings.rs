/* automatically generated by rust-bindgen */

pub const RS2_PRODUCT_LINE_ANY: u32 = 255;
pub const RS2_PRODUCT_LINE_ANY_INTEL: u32 = 254;
pub const RS2_PRODUCT_LINE_NON_INTEL: u32 = 1;
pub const RS2_PRODUCT_LINE_D400: u32 = 2;
pub const RS2_PRODUCT_LINE_SR300: u32 = 4;
pub const RS2_PRODUCT_LINE_L500: u32 = 8;
pub const RS2_PRODUCT_LINE_T200: u32 = 16;
pub const RS2_PRODUCT_LINE_DEPTH: u32 = 14;
pub const RS2_PRODUCT_LINE_TRACKING: u32 = 16;
pub const RS2_UNSIGNED_UPDATE_MODE_UPDATE: u32 = 0;
pub const RS2_UNSIGNED_UPDATE_MODE_READ_ONLY: u32 = 1;
pub const RS2_UNSIGNED_UPDATE_MODE_FULL: u32 = 2;
pub const RS2_API_MAJOR_VERSION: u32 = 2;
pub const RS2_API_MINOR_VERSION: u32 = 32;
pub const RS2_API_PATCH_VERSION: u32 = 1;
pub const RS2_API_BUILD_VERSION: u32 = 0;
pub const RS2_API_VERSION: u32 = 23201;
pub const RS2_DEFAULT_TIMEOUT: u32 = 15000;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
///< Frames didn't arrived within 5 seconds
pub const rs2_notification_category_RS2_NOTIFICATION_CATEGORY_FRAMES_TIMEOUT:
    rs2_notification_category = 0;
///< Received partial/incomplete frame
pub const rs2_notification_category_RS2_NOTIFICATION_CATEGORY_FRAME_CORRUPTED:
    rs2_notification_category = 1;
///< Error reported from the device
pub const rs2_notification_category_RS2_NOTIFICATION_CATEGORY_HARDWARE_ERROR:
    rs2_notification_category = 2;
///< General Hardeware notification that is not an error
pub const rs2_notification_category_RS2_NOTIFICATION_CATEGORY_HARDWARE_EVENT:
    rs2_notification_category = 3;
///< Received unknown error from the device
pub const rs2_notification_category_RS2_NOTIFICATION_CATEGORY_UNKNOWN_ERROR:
    rs2_notification_category = 4;
///< Current firmware version installed is not the latest available
pub const rs2_notification_category_RS2_NOTIFICATION_CATEGORY_FIRMWARE_UPDATE_RECOMMENDED:
    rs2_notification_category = 5;
///< A relocalization event has updated the pose provided by a pose sensor
pub const rs2_notification_category_RS2_NOTIFICATION_CATEGORY_POSE_RELOCALIZATION:
    rs2_notification_category = 6;
///< Number of enumeration values. Not a valid input: intended to be used in for-loops.
pub const rs2_notification_category_RS2_NOTIFICATION_CATEGORY_COUNT: rs2_notification_category = 7;
/// \brief Category of the librealsense notification.
pub type rs2_notification_category = u32;
extern "C" {
    pub fn rs2_notification_category_to_string(
        category: rs2_notification_category,
    ) -> *const ::std::os::raw::c_char;
}
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_UNKNOWN: rs2_exception_type = 0;
///< Device was disconnected, this can be caused by outside intervention, by internal firmware error or due to insufficient power
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_CAMERA_DISCONNECTED: rs2_exception_type = 1;
///< Error was returned from the underlying OS-specific layer
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_BACKEND: rs2_exception_type = 2;
///< Invalid value was passed to the API
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_INVALID_VALUE: rs2_exception_type = 3;
///< Function precondition was violated
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_WRONG_API_CALL_SEQUENCE: rs2_exception_type = 4;
///< The method is not implemented at this point
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_NOT_IMPLEMENTED: rs2_exception_type = 5;
///< Device is in recovery mode and might require firmware update
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_DEVICE_IN_RECOVERY_MODE: rs2_exception_type = 6;
///< IO Device failure
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_IO: rs2_exception_type = 7;
///< Number of enumeration values. Not a valid input: intended to be used in for-loops.
pub const rs2_exception_type_RS2_EXCEPTION_TYPE_COUNT: rs2_exception_type = 8;
/// \brief Exception types are the different categories of errors that RealSense API might return.
pub type rs2_exception_type = u32;
extern "C" {
    pub fn rs2_exception_type_to_string(type_: rs2_exception_type)
        -> *const ::std::os::raw::c_char;
}
///< Rectilinear images. No distortion compensation required.
pub const rs2_distortion_RS2_DISTORTION_NONE: rs2_distortion = 0;
///< Equivalent to Brown-Conrady distortion, except that tangential distortion is applied to radially distorted points
pub const rs2_distortion_RS2_DISTORTION_MODIFIED_BROWN_CONRADY: rs2_distortion = 1;
///< Equivalent to Brown-Conrady distortion, except undistorts image instead of distorting it
pub const rs2_distortion_RS2_DISTORTION_INVERSE_BROWN_CONRADY: rs2_distortion = 2;
///< F-Theta fish-eye distortion model
pub const rs2_distortion_RS2_DISTORTION_FTHETA: rs2_distortion = 3;
///< Unmodified Brown-Conrady distortion model
pub const rs2_distortion_RS2_DISTORTION_BROWN_CONRADY: rs2_distortion = 4;
///< Four parameter Kannala Brandt distortion model
pub const rs2_distortion_RS2_DISTORTION_KANNALA_BRANDT4: rs2_distortion = 5;
///< Number of enumeration values. Not a valid input: intended to be used in for-loops.
pub const rs2_distortion_RS2_DISTORTION_COUNT: rs2_distortion = 6;
/// \brief Distortion model: defines how pixel coordinates should be mapped to sensor coordinates.
pub type rs2_distortion = u32;
extern "C" {
    pub fn rs2_distortion_to_string(distortion: rs2_distortion) -> *const ::std::os::raw::c_char;
}
/// \brief Video stream intrinsics.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_intrinsics {
    ///< Width of the image in pixels
    pub width: ::std::os::raw::c_int,
    ///< Height of the image in pixels
    pub height: ::std::os::raw::c_int,
    ///< Horizontal coordinate of the principal point of the image, as a pixel offset from the left edge
    pub ppx: f32,
    ///< Vertical coordinate of the principal point of the image, as a pixel offset from the top edge
    pub ppy: f32,
    ///< Focal length of the image plane, as a multiple of pixel width
    pub fx: f32,
    ///< Focal length of the image plane, as a multiple of pixel height
    pub fy: f32,
    ///< Distortion model of the image
    pub model: rs2_distortion,
    ///< Distortion coefficients
    pub coeffs: [f32; 5usize],
}
#[test]
fn bindgen_test_layout_rs2_intrinsics() {
    assert_eq!(
        ::std::mem::size_of::<rs2_intrinsics>(),
        48usize,
        concat!("Size of: ", stringify!(rs2_intrinsics))
    );
    assert_eq!(
        ::std::mem::align_of::<rs2_intrinsics>(),
        4usize,
        concat!("Alignment of ", stringify!(rs2_intrinsics))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_intrinsics>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_intrinsics),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_intrinsics>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_intrinsics),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_intrinsics>())).ppx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_intrinsics),
            "::",
            stringify!(ppx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_intrinsics>())).ppy as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_intrinsics),
            "::",
            stringify!(ppy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_intrinsics>())).fx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_intrinsics),
            "::",
            stringify!(fx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_intrinsics>())).fy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_intrinsics),
            "::",
            stringify!(fy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_intrinsics>())).model as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_intrinsics),
            "::",
            stringify!(model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_intrinsics>())).coeffs as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_intrinsics),
            "::",
            stringify!(coeffs)
        )
    );
}
/// \brief Motion device intrinsics: scale, bias, and variances.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_motion_device_intrinsic {
    ///< Interpret data array values
    pub data: [[f32; 4usize]; 3usize],
    ///< Variance of noise for X, Y, and Z axis
    pub noise_variances: [f32; 3usize],
    ///< Variance of bias for X, Y, and Z axis
    pub bias_variances: [f32; 3usize],
}
#[test]
fn bindgen_test_layout_rs2_motion_device_intrinsic() {
    assert_eq!(
        ::std::mem::size_of::<rs2_motion_device_intrinsic>(),
        72usize,
        concat!("Size of: ", stringify!(rs2_motion_device_intrinsic))
    );
    assert_eq!(
        ::std::mem::align_of::<rs2_motion_device_intrinsic>(),
        4usize,
        concat!("Alignment of ", stringify!(rs2_motion_device_intrinsic))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rs2_motion_device_intrinsic>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_motion_device_intrinsic),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rs2_motion_device_intrinsic>())).noise_variances as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_motion_device_intrinsic),
            "::",
            stringify!(noise_variances)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rs2_motion_device_intrinsic>())).bias_variances as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_motion_device_intrinsic),
            "::",
            stringify!(bias_variances)
        )
    );
}
/// \brief 3D coordinates with origin at topmost left corner of the lense,
///with positive Z pointing away from the camera, positive X pointing camera right and positive Y pointing camera down
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_vertex {
    pub xyz: [f32; 3usize],
}
#[test]
fn bindgen_test_layout_rs2_vertex() {
    assert_eq!(
        ::std::mem::size_of::<rs2_vertex>(),
        12usize,
        concat!("Size of: ", stringify!(rs2_vertex))
    );
    assert_eq!(
        ::std::mem::align_of::<rs2_vertex>(),
        4usize,
        concat!("Alignment of ", stringify!(rs2_vertex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_vertex>())).xyz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_vertex),
            "::",
            stringify!(xyz)
        )
    );
}
/// \brief Pixel location within 2D image. (0,0) is the topmost, left corner. Positive X is right, positive Y is down
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_pixel {
    pub ij: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout_rs2_pixel() {
    assert_eq!(
        ::std::mem::size_of::<rs2_pixel>(),
        8usize,
        concat!("Size of: ", stringify!(rs2_pixel))
    );
    assert_eq!(
        ::std::mem::align_of::<rs2_pixel>(),
        4usize,
        concat!("Alignment of ", stringify!(rs2_pixel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pixel>())).ij as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pixel),
            "::",
            stringify!(ij)
        )
    );
}
/// \brief 3D vector in Euclidean coordinate space
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_vector {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_rs2_vector() {
    assert_eq!(
        ::std::mem::size_of::<rs2_vector>(),
        12usize,
        concat!("Size of: ", stringify!(rs2_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<rs2_vector>(),
        4usize,
        concat!("Alignment of ", stringify!(rs2_vector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_vector>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_vector),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_vector>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_vector),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_vector>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_vector),
            "::",
            stringify!(z)
        )
    );
}
/// \brief Quaternion used to represent rotation
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_quaternion {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_rs2_quaternion() {
    assert_eq!(
        ::std::mem::size_of::<rs2_quaternion>(),
        16usize,
        concat!("Size of: ", stringify!(rs2_quaternion))
    );
    assert_eq!(
        ::std::mem::align_of::<rs2_quaternion>(),
        4usize,
        concat!("Alignment of ", stringify!(rs2_quaternion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_quaternion>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_quaternion),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_quaternion>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_quaternion),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_quaternion>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_quaternion),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_quaternion>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_quaternion),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_pose {
    ///< X, Y, Z values of translation, in meters (relative to initial position)
    pub translation: rs2_vector,
    ///< X, Y, Z values of velocity, in meters/sec
    pub velocity: rs2_vector,
    ///< X, Y, Z values of acceleration, in meters/sec^2
    pub acceleration: rs2_vector,
    ///< Qi, Qj, Qk, Qr components of rotation as represented in quaternion rotation (relative to initial position)
    pub rotation: rs2_quaternion,
    ///< X, Y, Z values of angular velocity, in radians/sec
    pub angular_velocity: rs2_vector,
    ///< X, Y, Z values of angular acceleration, in radians/sec^2
    pub angular_acceleration: rs2_vector,
    ///< Pose confidence 0x0 - Failed, 0x1 - Low, 0x2 - Medium, 0x3 - High
    pub tracker_confidence: ::std::os::raw::c_uint,
    ///< Pose map confidence 0x0 - Failed, 0x1 - Low, 0x2 - Medium, 0x3 - High
    pub mapper_confidence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rs2_pose() {
    assert_eq!(
        ::std::mem::size_of::<rs2_pose>(),
        84usize,
        concat!("Size of: ", stringify!(rs2_pose))
    );
    assert_eq!(
        ::std::mem::align_of::<rs2_pose>(),
        4usize,
        concat!("Alignment of ", stringify!(rs2_pose))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pose>())).translation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pose),
            "::",
            stringify!(translation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pose>())).velocity as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pose),
            "::",
            stringify!(velocity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pose>())).acceleration as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pose),
            "::",
            stringify!(acceleration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pose>())).rotation as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pose),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pose>())).angular_velocity as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pose),
            "::",
            stringify!(angular_velocity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pose>())).angular_acceleration as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pose),
            "::",
            stringify!(angular_acceleration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pose>())).tracker_confidence as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pose),
            "::",
            stringify!(tracker_confidence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_pose>())).mapper_confidence as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_pose),
            "::",
            stringify!(mapper_confidence)
        )
    );
}
///< Detailed information about ordinary operations
pub const rs2_log_severity_RS2_LOG_SEVERITY_DEBUG: rs2_log_severity = 0;
///< Terse information about ordinary operations
pub const rs2_log_severity_RS2_LOG_SEVERITY_INFO: rs2_log_severity = 1;
///< Indication of possible failure
pub const rs2_log_severity_RS2_LOG_SEVERITY_WARN: rs2_log_severity = 2;
///< Indication of definite failure
pub const rs2_log_severity_RS2_LOG_SEVERITY_ERROR: rs2_log_severity = 3;
///< Indication of unrecoverable failure
pub const rs2_log_severity_RS2_LOG_SEVERITY_FATAL: rs2_log_severity = 4;
///< No logging will occur
pub const rs2_log_severity_RS2_LOG_SEVERITY_NONE: rs2_log_severity = 5;
///< Number of enumeration values. Not a valid input: intended to be used in for-loops.
pub const rs2_log_severity_RS2_LOG_SEVERITY_COUNT: rs2_log_severity = 6;
/// \brief Severity of the librealsense logger.
pub type rs2_log_severity = u32;
extern "C" {
    pub fn rs2_log_severity_to_string(info: rs2_log_severity) -> *const ::std::os::raw::c_char;
}
pub const rs2_extension_RS2_EXTENSION_UNKNOWN: rs2_extension = 0;
pub const rs2_extension_RS2_EXTENSION_DEBUG: rs2_extension = 1;
pub const rs2_extension_RS2_EXTENSION_INFO: rs2_extension = 2;
pub const rs2_extension_RS2_EXTENSION_MOTION: rs2_extension = 3;
pub const rs2_extension_RS2_EXTENSION_OPTIONS: rs2_extension = 4;
pub const rs2_extension_RS2_EXTENSION_VIDEO: rs2_extension = 5;
pub const rs2_extension_RS2_EXTENSION_ROI: rs2_extension = 6;
pub const rs2_extension_RS2_EXTENSION_DEPTH_SENSOR: rs2_extension = 7;
pub const rs2_extension_RS2_EXTENSION_VIDEO_FRAME: rs2_extension = 8;
pub const rs2_extension_RS2_EXTENSION_MOTION_FRAME: rs2_extension = 9;
pub const rs2_extension_RS2_EXTENSION_COMPOSITE_FRAME: rs2_extension = 10;
pub const rs2_extension_RS2_EXTENSION_POINTS: rs2_extension = 11;
pub const rs2_extension_RS2_EXTENSION_DEPTH_FRAME: rs2_extension = 12;
pub const rs2_extension_RS2_EXTENSION_ADVANCED_MODE: rs2_extension = 13;
pub const rs2_extension_RS2_EXTENSION_RECORD: rs2_extension = 14;
pub const rs2_extension_RS2_EXTENSION_VIDEO_PROFILE: rs2_extension = 15;
pub const rs2_extension_RS2_EXTENSION_PLAYBACK: rs2_extension = 16;
pub const rs2_extension_RS2_EXTENSION_DEPTH_STEREO_SENSOR: rs2_extension = 17;
pub const rs2_extension_RS2_EXTENSION_DISPARITY_FRAME: rs2_extension = 18;
pub const rs2_extension_RS2_EXTENSION_MOTION_PROFILE: rs2_extension = 19;
pub const rs2_extension_RS2_EXTENSION_POSE_FRAME: rs2_extension = 20;
pub const rs2_extension_RS2_EXTENSION_POSE_PROFILE: rs2_extension = 21;
pub const rs2_extension_RS2_EXTENSION_TM2: rs2_extension = 22;
pub const rs2_extension_RS2_EXTENSION_SOFTWARE_DEVICE: rs2_extension = 23;
pub const rs2_extension_RS2_EXTENSION_SOFTWARE_SENSOR: rs2_extension = 24;
pub const rs2_extension_RS2_EXTENSION_DECIMATION_FILTER: rs2_extension = 25;
pub const rs2_extension_RS2_EXTENSION_THRESHOLD_FILTER: rs2_extension = 26;
pub const rs2_extension_RS2_EXTENSION_DISPARITY_FILTER: rs2_extension = 27;
pub const rs2_extension_RS2_EXTENSION_SPATIAL_FILTER: rs2_extension = 28;
pub const rs2_extension_RS2_EXTENSION_TEMPORAL_FILTER: rs2_extension = 29;
pub const rs2_extension_RS2_EXTENSION_HOLE_FILLING_FILTER: rs2_extension = 30;
pub const rs2_extension_RS2_EXTENSION_ZERO_ORDER_FILTER: rs2_extension = 31;
pub const rs2_extension_RS2_EXTENSION_RECOMMENDED_FILTERS: rs2_extension = 32;
pub const rs2_extension_RS2_EXTENSION_POSE: rs2_extension = 33;
pub const rs2_extension_RS2_EXTENSION_POSE_SENSOR: rs2_extension = 34;
pub const rs2_extension_RS2_EXTENSION_WHEEL_ODOMETER: rs2_extension = 35;
pub const rs2_extension_RS2_EXTENSION_GLOBAL_TIMER: rs2_extension = 36;
pub const rs2_extension_RS2_EXTENSION_UPDATABLE: rs2_extension = 37;
pub const rs2_extension_RS2_EXTENSION_UPDATE_DEVICE: rs2_extension = 38;
pub const rs2_extension_RS2_EXTENSION_L500_DEPTH_SENSOR: rs2_extension = 39;
pub const rs2_extension_RS2_EXTENSION_TM2_SENSOR: rs2_extension = 40;
pub const rs2_extension_RS2_EXTENSION_AUTO_CALIBRATED_DEVICE: rs2_extension = 41;
pub const rs2_extension_RS2_EXTENSION_COLOR_SENSOR: rs2_extension = 42;
pub const rs2_extension_RS2_EXTENSION_MOTION_SENSOR: rs2_extension = 43;
pub const rs2_extension_RS2_EXTENSION_FISHEYE_SENSOR: rs2_extension = 44;
pub const rs2_extension_RS2_EXTENSION_DEPTH_HUFFMAN_DECODER: rs2_extension = 45;
pub const rs2_extension_RS2_EXTENSION_COUNT: rs2_extension = 46;
/// \brief Specifies advanced interfaces (capabilities) objects may implement.
pub type rs2_extension = u32;
extern "C" {
    pub fn rs2_extension_type_to_string(type_: rs2_extension) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_extension_to_string(type_: rs2_extension) -> *const ::std::os::raw::c_char;
}
pub const rs2_matchers_RS2_MATCHER_DI: rs2_matchers = 0;
pub const rs2_matchers_RS2_MATCHER_DI_C: rs2_matchers = 1;
pub const rs2_matchers_RS2_MATCHER_DLR_C: rs2_matchers = 2;
pub const rs2_matchers_RS2_MATCHER_DLR: rs2_matchers = 3;
pub const rs2_matchers_RS2_MATCHER_DIC: rs2_matchers = 4;
pub const rs2_matchers_RS2_MATCHER_DIC_C: rs2_matchers = 5;
pub const rs2_matchers_RS2_MATCHER_DEFAULT: rs2_matchers = 6;
pub const rs2_matchers_RS2_MATCHER_COUNT: rs2_matchers = 7;
/// \brief Specifies types of different matchers
pub type rs2_matchers = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_device_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_error {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_raw_data_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_frame {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_frame_queue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_pipeline {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_pipeline_profile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_config {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_device_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_stream_profile_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_processing_block_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_stream_profile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_frame_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_log_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_syncer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_device_serializer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_source {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_processing_block {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_frame_processor_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_playback_status_changed_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_update_progress_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_device_hub {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_sensor_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_sensor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_options {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_options_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_devices_changed_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_notification {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_notifications_callback {
    _unused: [u8; 0],
}
pub type rs2_notification_callback_ptr = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut rs2_notification, arg2: *mut ::std::os::raw::c_void),
>;
pub type rs2_devices_changed_callback_ptr = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut rs2_device_list,
        arg2: *mut rs2_device_list,
        arg3: *mut ::std::os::raw::c_void,
    ),
>;
pub type rs2_frame_callback_ptr = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut rs2_frame, arg2: *mut ::std::os::raw::c_void),
>;
pub type rs2_frame_processor_callback_ptr = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut rs2_frame,
        arg2: *mut rs2_source,
        arg3: *mut ::std::os::raw::c_void,
    ),
>;
pub type rs2_update_progress_callback_ptr =
    ::std::option::Option<unsafe extern "C" fn(arg1: f32, arg2: *mut ::std::os::raw::c_void)>;
pub type rs2_time_t = f64;
pub type rs2_metadata_type = ::std::os::raw::c_longlong;
extern "C" {
    pub fn rs2_create_error(
        what: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        args: *const ::std::os::raw::c_char,
        type_: rs2_exception_type,
    ) -> *mut rs2_error;
}
extern "C" {
    pub fn rs2_get_librealsense_exception_type(error: *const rs2_error) -> rs2_exception_type;
}
extern "C" {
    pub fn rs2_get_failed_function(error: *const rs2_error) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_get_failed_args(error: *const rs2_error) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_get_error_message(error: *const rs2_error) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_free_error(error: *mut rs2_error);
}
extern "C" {
    /// \brief Creates RealSense context that is required for the rest of the API.
    /// \param[in] api_version Users are expected to pass their version of \c RS2_API_VERSION to make sure they are running the correct librealsense version.
    /// \param[out] error  If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
    /// \return            Context object
    pub fn rs2_create_context(
        api_version: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_context;
}
extern "C" {
    /// \brief Frees the relevant context object.
    /// \param[in] context Object that is no longer needed
    pub fn rs2_delete_context(context: *mut rs2_context);
}
extern "C" {
    /// set callback to get devices changed events
    /// these events will be raised by the context whenever new RealSense device is connected or existing device gets disconnected
    /// \param context     Object representing librealsense session
    /// \param[in] callback callback object created from c++ application. ownership over the callback object is moved into the context
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_set_devices_changed_callback_cpp(
        context: *mut rs2_context,
        callback: *mut rs2_devices_changed_callback,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// set callback to get devices changed events
    /// these events will be raised by the context whenever new RealSense device is connected or existing device gets disconnected
    /// \param context     Object representing librealsense session
    /// \param[in] callback function pointer to register as per-notifications callback
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_set_devices_changed_callback(
        context: *const rs2_context,
        callback: rs2_devices_changed_callback_ptr,
        user: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Create a new device and add it to the context
    /// \param ctx   The context to which the new device will be added
    /// \param file  The file from which the device should be created
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// @return  A pointer to a device that plays data from the file, or null in case of failure
    pub fn rs2_context_add_device(
        ctx: *mut rs2_context,
        file: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device;
}
extern "C" {
    /// Add an instance of software device to the context
    /// \param ctx   The context to which the new device will be added
    /// \param dev   Instance of software device to register into the context
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_context_add_software_device(
        ctx: *mut rs2_context,
        dev: *mut rs2_device,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Removes a playback device from the context, if exists
    /// \param[in]  ctx       The context from which the device should be removed
    /// \param[in]  file      The file name that was used to add the device
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_context_remove_device(
        ctx: *mut rs2_context,
        file: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Removes tracking module.
    /// function query_devices() locks the tracking module in the tm_context object.
    /// If the tracking module device is not used it should be removed using this function, so that other applications could find it.
    /// This function can be used both before the call to query_device() to prevent enabling tracking modules or afterwards to
    /// release them.
    pub fn rs2_context_unload_tracking_module(ctx: *mut rs2_context, error: *mut *mut rs2_error);
}
extern "C" {
    /// create a static snapshot of all connected devices at the time of the call
    /// \param context     Object representing librealsense session
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return            the list of devices, should be released by rs2_delete_device_list
    pub fn rs2_query_devices(
        context: *const rs2_context,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device_list;
}
extern "C" {
    /// create a static snapshot of all connected devices at the time of the call
    /// \param context     Object representing librealsense session
    /// \param product_mask Controls what kind of devices will be returned
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return            the list of devices, should be released by rs2_delete_device_list
    pub fn rs2_query_devices_ex(
        context: *const rs2_context,
        product_mask: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device_list;
}
extern "C" {
    /// \brief Creates RealSense device_hub .
    /// \param[in] context The context for the device hub
    /// \param[out] error  If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
    /// \return            Device hub object
    pub fn rs2_create_device_hub(
        context: *const rs2_context,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device_hub;
}
extern "C" {
    /// \brief Frees the relevant device hub object.
    /// \param[in] hub Object that is no longer needed
    pub fn rs2_delete_device_hub(hub: *const rs2_device_hub);
}
extern "C" {
    /// If any device is connected return it, otherwise wait until next RealSense device connects.
    /// Calling this method multiple times will cycle through connected devices
    /// \param[in] ctx The context to creat the device
    /// \param[in] hub The device hub object
    /// \param[out] error  If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
    /// \return            device object
    pub fn rs2_device_hub_wait_for_device(
        hub: *const rs2_device_hub,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device;
}
extern "C" {
    /// Checks if device is still connected
    /// \param[in] hub The device hub object
    /// \param[in] device The device
    /// \param[out] error  If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
    /// \return            1 if the device is connected, 0 otherwise
    pub fn rs2_device_hub_is_device_connected(
        hub: *const rs2_device_hub,
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
///< Friendly name
pub const rs2_camera_info_RS2_CAMERA_INFO_NAME: rs2_camera_info = 0;
///< Device serial number
pub const rs2_camera_info_RS2_CAMERA_INFO_SERIAL_NUMBER: rs2_camera_info = 1;
///< Primary firmware version
pub const rs2_camera_info_RS2_CAMERA_INFO_FIRMWARE_VERSION: rs2_camera_info = 2;
///< Recommended firmware version
pub const rs2_camera_info_RS2_CAMERA_INFO_RECOMMENDED_FIRMWARE_VERSION: rs2_camera_info = 3;
///< Unique identifier of the port the device is connected to (platform specific)
pub const rs2_camera_info_RS2_CAMERA_INFO_PHYSICAL_PORT: rs2_camera_info = 4;
///< If device supports firmware logging, this is the command to send to get logs from firmware
pub const rs2_camera_info_RS2_CAMERA_INFO_DEBUG_OP_CODE: rs2_camera_info = 5;
///< True iff the device is in advanced mode
pub const rs2_camera_info_RS2_CAMERA_INFO_ADVANCED_MODE: rs2_camera_info = 6;
///< Product ID as reported in the USB descriptor
pub const rs2_camera_info_RS2_CAMERA_INFO_PRODUCT_ID: rs2_camera_info = 7;
///< True iff EEPROM is locked
pub const rs2_camera_info_RS2_CAMERA_INFO_CAMERA_LOCKED: rs2_camera_info = 8;
///< Designated USB specification: USB2/USB3
pub const rs2_camera_info_RS2_CAMERA_INFO_USB_TYPE_DESCRIPTOR: rs2_camera_info = 9;
///< Device product line D400/SR300/L500/T200
pub const rs2_camera_info_RS2_CAMERA_INFO_PRODUCT_LINE: rs2_camera_info = 10;
///< ASIC serial number
pub const rs2_camera_info_RS2_CAMERA_INFO_ASIC_SERIAL_NUMBER: rs2_camera_info = 11;
///< Firmware update ID
pub const rs2_camera_info_RS2_CAMERA_INFO_FIRMWARE_UPDATE_ID: rs2_camera_info = 12;
///< Number of enumeration values. Not a valid input: intended to be used in for-loops.
pub const rs2_camera_info_RS2_CAMERA_INFO_COUNT: rs2_camera_info = 13;
/// \brief Read-only strings that can be queried from the device.
///Not all information attributes are available on all camera types.
///This information is mainly available for camera debug and troubleshooting and should not be used in applications.
pub type rs2_camera_info = u32;
extern "C" {
    pub fn rs2_camera_info_to_string(info: rs2_camera_info) -> *const ::std::os::raw::c_char;
}
pub const rs2_stream_RS2_STREAM_ANY: rs2_stream = 0;
///< Native stream of depth data produced by RealSense device
pub const rs2_stream_RS2_STREAM_DEPTH: rs2_stream = 1;
///< Native stream of color data captured by RealSense device
pub const rs2_stream_RS2_STREAM_COLOR: rs2_stream = 2;
///< Native stream of infrared data captured by RealSense device
pub const rs2_stream_RS2_STREAM_INFRARED: rs2_stream = 3;
///< Native stream of fish-eye (wide) data captured from the dedicate motion camera
pub const rs2_stream_RS2_STREAM_FISHEYE: rs2_stream = 4;
///< Native stream of gyroscope motion data produced by RealSense device
pub const rs2_stream_RS2_STREAM_GYRO: rs2_stream = 5;
///< Native stream of accelerometer motion data produced by RealSense device
pub const rs2_stream_RS2_STREAM_ACCEL: rs2_stream = 6;
///< Signals from external device connected through GPIO
pub const rs2_stream_RS2_STREAM_GPIO: rs2_stream = 7;
///< 6 Degrees of Freedom pose data, calculated by RealSense device
pub const rs2_stream_RS2_STREAM_POSE: rs2_stream = 8;
///< 4 bit per-pixel depth confidence level
pub const rs2_stream_RS2_STREAM_CONFIDENCE: rs2_stream = 9;
pub const rs2_stream_RS2_STREAM_COUNT: rs2_stream = 10;
/// \brief Streams are different types of data provided by RealSense devices.
pub type rs2_stream = u32;
extern "C" {
    pub fn rs2_stream_to_string(stream: rs2_stream) -> *const ::std::os::raw::c_char;
}
///< When passed to enable stream, librealsense will try to provide best suited format
pub const rs2_format_RS2_FORMAT_ANY: rs2_format = 0;
///< 16-bit linear depth values. The depth is meters is equal to depth scale * pixel value.
pub const rs2_format_RS2_FORMAT_Z16: rs2_format = 1;
///< 16-bit float-point disparity values. Depth->Disparity conversion : Disparity = Baseline*FocalLength/Depth.
pub const rs2_format_RS2_FORMAT_DISPARITY16: rs2_format = 2;
///< 32-bit floating point 3D coordinates.
pub const rs2_format_RS2_FORMAT_XYZ32F: rs2_format = 3;
///< 32-bit y0, u, y1, v data for every two pixels. Similar to YUV422 but packed in a different order - https://en.wikipedia.org/wiki/YUV
pub const rs2_format_RS2_FORMAT_YUYV: rs2_format = 4;
///< 8-bit red, green and blue channels
pub const rs2_format_RS2_FORMAT_RGB8: rs2_format = 5;
///< 8-bit blue, green, and red channels -- suitable for OpenCV
pub const rs2_format_RS2_FORMAT_BGR8: rs2_format = 6;
///< 8-bit red, green and blue channels + constant alpha channel equal to FF
pub const rs2_format_RS2_FORMAT_RGBA8: rs2_format = 7;
///< 8-bit blue, green, and red channels + constant alpha channel equal to FF
pub const rs2_format_RS2_FORMAT_BGRA8: rs2_format = 8;
///< 8-bit per-pixel grayscale image
pub const rs2_format_RS2_FORMAT_Y8: rs2_format = 9;
///< 16-bit per-pixel grayscale image
pub const rs2_format_RS2_FORMAT_Y16: rs2_format = 10;
///< Four 10 bits per pixel luminance values packed into a 5-byte macropixel
pub const rs2_format_RS2_FORMAT_RAW10: rs2_format = 11;
///< 16-bit raw image
pub const rs2_format_RS2_FORMAT_RAW16: rs2_format = 12;
///< 8-bit raw image
pub const rs2_format_RS2_FORMAT_RAW8: rs2_format = 13;
///< Similar to the standard YUYV pixel format, but packed in a different order
pub const rs2_format_RS2_FORMAT_UYVY: rs2_format = 14;
///< Raw data from the motion sensor
pub const rs2_format_RS2_FORMAT_MOTION_RAW: rs2_format = 15;
///< Motion data packed as 3 32-bit float values, for X, Y, and Z axis
pub const rs2_format_RS2_FORMAT_MOTION_XYZ32F: rs2_format = 16;
///< Raw data from the external sensors hooked to one of the GPIO's
pub const rs2_format_RS2_FORMAT_GPIO_RAW: rs2_format = 17;
///< Pose data packed as floats array, containing translation vector, rotation quaternion and prediction velocities and accelerations vectors
pub const rs2_format_RS2_FORMAT_6DOF: rs2_format = 18;
///< 32-bit float-point disparity values. Depth->Disparity conversion : Disparity = Baseline*FocalLength/Depth
pub const rs2_format_RS2_FORMAT_DISPARITY32: rs2_format = 19;
///< 16-bit per-pixel grayscale image unpacked from 10 bits per pixel packed ([8:8:8:8:2222]) grey-scale image. The data is unpacked to LSB and padded with 6 zero bits
pub const rs2_format_RS2_FORMAT_Y10BPACK: rs2_format = 20;
///< 32-bit float-point depth distance value.
pub const rs2_format_RS2_FORMAT_DISTANCE: rs2_format = 21;
///< Bitstream encoding for video in which an image of each frame is encoded as JPEG-DIB
pub const rs2_format_RS2_FORMAT_MJPEG: rs2_format = 22;
///< 8-bit per pixel interleaved. 8-bit left, 8-bit right.
pub const rs2_format_RS2_FORMAT_Y8I: rs2_format = 23;
///< 12-bit per pixel interleaved. 12-bit left, 12-bit right. Each pixel is stored in a 24-bit word in little-endian order.
pub const rs2_format_RS2_FORMAT_Y12I: rs2_format = 24;
///< multi-planar Depth 16bit + IR 10bit.
pub const rs2_format_RS2_FORMAT_INZI: rs2_format = 25;
///< 8-bit IR stream.
pub const rs2_format_RS2_FORMAT_INVI: rs2_format = 26;
///< Grey-scale image as a bit-packed array. 4 pixel data stream taking 5 bytes
pub const rs2_format_RS2_FORMAT_W10: rs2_format = 27;
///< Variable-length Huffman-compressed 16-bit depth values.
pub const rs2_format_RS2_FORMAT_Z16H: rs2_format = 28;
///< Number of enumeration values. Not a valid input: intended to be used in for-loops.
pub const rs2_format_RS2_FORMAT_COUNT: rs2_format = 29;
/// \brief A stream's format identifies how binary data is encoded within a frame.
pub type rs2_format = u32;
extern "C" {
    pub fn rs2_format_to_string(format: rs2_format) -> *const ::std::os::raw::c_char;
}
/// \brief Cross-stream extrinsics: encodes the topology describing how the different devices are oriented.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rs2_extrinsics {
    ///< Column-major 3x3 rotation matrix
    pub rotation: [f32; 9usize],
    ///< Three-element translation vector, in meters
    pub translation: [f32; 3usize],
}
#[test]
fn bindgen_test_layout_rs2_extrinsics() {
    assert_eq!(
        ::std::mem::size_of::<rs2_extrinsics>(),
        48usize,
        concat!("Size of: ", stringify!(rs2_extrinsics))
    );
    assert_eq!(
        ::std::mem::align_of::<rs2_extrinsics>(),
        4usize,
        concat!("Alignment of ", stringify!(rs2_extrinsics))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_extrinsics>())).rotation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_extrinsics),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rs2_extrinsics>())).translation as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rs2_extrinsics),
            "::",
            stringify!(translation)
        )
    );
}
extern "C" {
    /// Deletes sensors list, any sensors created from this list will remain unaffected
    /// \param[in] info_list list to delete
    pub fn rs2_delete_sensor_list(info_list: *mut rs2_sensor_list);
}
extern "C" {
    /// Determines number of sensors in a list
    /// \param[in] info_list The list of connected sensors captured using rs2_query_sensors
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return            Sensors count
    pub fn rs2_get_sensors_count(
        info_list: *const rs2_sensor_list,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// delete relasense sensor
    /// \param[in] sensor realsense sensor to delete
    pub fn rs2_delete_sensor(sensor: *mut rs2_sensor);
}
extern "C" {
    /// create sensor by index
    /// \param[in] index   the zero based index of sensor to retrieve
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return            the requested sensor, should be released by rs2_delete_sensor
    pub fn rs2_create_sensor(
        list: *const rs2_sensor_list,
        index: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_sensor;
}
extern "C" {
    /// This is a helper function allowing the user to discover the device from one of its sensors
    /// \param[in] sensor     Pointer to a sensor
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               new device wrapper for the device of the sensor. Needs to be released by delete_device
    pub fn rs2_create_device_from_sensor(
        sensor: *const rs2_sensor,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device;
}
extern "C" {
    /// retrieve sensor specific information, like versions of various internal components
    /// \param[in] sensor     the RealSense sensor
    /// \param[in] info       camera info type to retrieve
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               the requested camera info string, in a format specific to the device model
    pub fn rs2_get_sensor_info(
        sensor: *const rs2_sensor,
        info: rs2_camera_info,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// check if specific sensor info is supported
    /// \param[in] info    the parameter to check for support
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                true if the parameter both exist and well-defined for the specific device
    pub fn rs2_supports_sensor_info(
        sensor: *const rs2_sensor,
        info: rs2_camera_info,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Test if the given sensor can be extended to the requested extension
    /// \param[in] sensor  Realsense sensor
    /// \param[in] extension The extension to which the sensor should be tested if it is extendable
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return non-zero value iff the sensor can be extended to the given extension
    pub fn rs2_is_sensor_extendable_to(
        sensor: *const rs2_sensor,
        extension: rs2_extension,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// When called on a depth sensor, this method will return the number of meters represented by a single depth unit
    /// \param[in] sensor      depth sensor
    /// \param[out] error      if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                the number of meters represented by a single depth unit
    pub fn rs2_get_depth_scale(sensor: *mut rs2_sensor, error: *mut *mut rs2_error) -> f32;
}
extern "C" {
    /// Retrieve the stereoscopic baseline value from frame. Applicable to stereo-based depth modules
    /// \param[out] float  Stereoscopic baseline in millimeters
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_depth_stereo_frame_get_baseline(
        frame_ref: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> f32;
}
extern "C" {
    /// Retrieve the stereoscopic baseline value from sensor. Applicable to stereo-based depth modules
    /// \param[out] float  Stereoscopic baseline in millimeters
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_get_stereo_baseline(sensor: *mut rs2_sensor, error: *mut *mut rs2_error) -> f32;
}
extern "C" {
    /// \brief sets the active region of interest to be used by auto-exposure algorithm
    /// \param[in] sensor     the RealSense sensor
    /// \param[in] min_x      lower horizontal bound in pixels
    /// \param[in] min_y      lower vertical bound in pixels
    /// \param[in] max_x      upper horizontal bound in pixels
    /// \param[in] max_y      upper vertical bound in pixels
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_set_region_of_interest(
        sensor: *const rs2_sensor,
        min_x: ::std::os::raw::c_int,
        min_y: ::std::os::raw::c_int,
        max_x: ::std::os::raw::c_int,
        max_y: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// \brief gets the active region of interest to be used by auto-exposure algorithm
    /// \param[in] sensor     the RealSense sensor
    /// \param[out] min_x     lower horizontal bound in pixels
    /// \param[out] min_y     lower vertical bound in pixels
    /// \param[out] max_x     upper horizontal bound in pixels
    /// \param[out] max_y     upper vertical bound in pixels
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_get_region_of_interest(
        sensor: *const rs2_sensor,
        min_x: *mut ::std::os::raw::c_int,
        min_y: *mut ::std::os::raw::c_int,
        max_x: *mut ::std::os::raw::c_int,
        max_y: *mut ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// open subdevice for exclusive access, by committing to a configuration
    /// \param[in] device relevant RealSense device
    /// \param[in] profile    stream profile that defines single stream configuration
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_open(
        device: *mut rs2_sensor,
        profile: *const rs2_stream_profile,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// open subdevice for exclusive access, by committing to composite configuration, specifying one or more stream profiles
    /// this method should be used for interdependent  streams, such as depth and infrared, that have to be configured together
    /// \param[in] device relevant RealSense device
    /// \param[in] profiles  list of stream profiles discovered by get_stream_profiles
    /// \param[in] count      number of simultaneous  stream profiles to configure
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_open_multiple(
        device: *mut rs2_sensor,
        profiles: *mut *const rs2_stream_profile,
        count: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// stop any streaming from specified subdevice
    /// \param[in] sensor     RealSense device
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_close(sensor: *const rs2_sensor, error: *mut *mut rs2_error);
}
extern "C" {
    /// start streaming from specified configured sensor
    /// \param[in] sensor  RealSense device
    /// \param[in] on_frame function pointer to register as per-frame callback
    /// \param[in] user auxiliary  data the user wishes to receive together with every frame callback
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_start(
        sensor: *const rs2_sensor,
        on_frame: rs2_frame_callback_ptr,
        user: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// start streaming from specified configured sensor
    /// \param[in] sensor  RealSense device
    /// \param[in] callback callback object created from c++ application. ownership over the callback object is moved into the relevant streaming lock
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_start_cpp(
        sensor: *const rs2_sensor,
        callback: *mut rs2_frame_callback,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// start streaming from specified configured sensor of specific stream to frame queue
    /// \param[in] sensor  RealSense Sensor
    /// \param[in] queue   frame-queue to store new frames into
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_start_queue(
        sensor: *const rs2_sensor,
        queue: *mut rs2_frame_queue,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// stops streaming from specified configured device
    /// \param[in] sensor  RealSense sensor
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_stop(sensor: *const rs2_sensor, error: *mut *mut rs2_error);
}
extern "C" {
    /// set callback to get notifications from specified sensor
    /// \param[in] sensor          RealSense device
    /// \param[in] on_notification function pointer to register as per-notifications callback
    /// \param[out] error          if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_set_notifications_callback(
        sensor: *const rs2_sensor,
        on_notification: rs2_notification_callback_ptr,
        user: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// set callback to get notifications from specified device
    /// \param[in] sensor  RealSense sensor
    /// \param[in] callback callback object created from c++ application. ownership over the callback object is moved into the relevant subdevice lock
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_set_notifications_callback_cpp(
        sensor: *const rs2_sensor,
        callback: *mut rs2_notifications_callback,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// retrieve description from notification handle
    /// \param[in] notification      handle returned from a callback
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return            the notification description
    pub fn rs2_get_notification_description(
        notification: *mut rs2_notification,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// retrieve timestamp from notification handle
    /// \param[in] notification      handle returned from a callback
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return            the notification timestamp
    pub fn rs2_get_notification_timestamp(
        notification: *mut rs2_notification,
        error: *mut *mut rs2_error,
    ) -> rs2_time_t;
}
extern "C" {
    /// retrieve severity from notification handle
    /// \param[in] notification      handle returned from a callback
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return            the notification severity
    pub fn rs2_get_notification_severity(
        notification: *mut rs2_notification,
        error: *mut *mut rs2_error,
    ) -> rs2_log_severity;
}
extern "C" {
    /// retrieve category from notification handle
    /// \param[in] notification      handle returned from a callback
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return            the notification category
    pub fn rs2_get_notification_category(
        notification: *mut rs2_notification,
        error: *mut *mut rs2_error,
    ) -> rs2_notification_category;
}
extern "C" {
    /// retrieve serialized data from notification handle
    /// \param[in] notification      handle returned from a callback
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return            the serialized data (in JSON format)
    pub fn rs2_get_notification_serialized_data(
        notification: *mut rs2_notification,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// check if physical subdevice is supported
    /// \param[in] device  input RealSense device
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return            list of stream profiles that given subdevice can provide, should be released by rs2_delete_profiles_list
    pub fn rs2_get_stream_profiles(
        device: *mut rs2_sensor,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_stream_profile_list;
}
extern "C" {
    /// Get pointer to specific stream profile
    /// \param[in] list        the list of supported profiles returned by rs2_get_supported_profiles
    /// \param[in] index       the zero based index of the streaming mode
    /// \param[out] error      if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_get_stream_profile(
        list: *const rs2_stream_profile_list,
        index: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *const rs2_stream_profile;
}
extern "C" {
    /// Extract common parameters of a stream profiles
    /// \param[in] mode        input stream profile
    /// \param[out] stream     stream type of the input profile
    /// \param[out] format     binary data format of the input profile
    /// \param[out] index      stream index the input profile in case there are multiple streams of the same type
    /// \param[out] unique_id  identifier for the stream profile, unique within the application
    /// \param[out] framerate  expected rate for data frames to arrive, meaning expected number of frames per second
    /// \param[out] error      if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_get_stream_profile_data(
        mode: *const rs2_stream_profile,
        stream: *mut rs2_stream,
        format: *mut rs2_format,
        index: *mut ::std::os::raw::c_int,
        unique_id: *mut ::std::os::raw::c_int,
        framerate: *mut ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Override some of the parameters of the stream profile
    /// \param[in] mode        input stream profile
    /// \param[in] stream      stream type for the profile
    /// \param[in] format      binary data format of the profile
    /// \param[in] index       stream index the profile in case there are multiple streams of the same type
    /// \param[out] error      if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_set_stream_profile_data(
        mode: *mut rs2_stream_profile,
        stream: rs2_stream,
        index: ::std::os::raw::c_int,
        format: rs2_format,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Creates a copy of stream profile, assigning new values to some of the fields
    /// \param[in] mode        input stream profile
    /// \param[in] stream      stream type for the profile
    /// \param[in] format      binary data format of the profile
    /// \param[in] index       stream index the profile in case there are multiple streams of the same type
    /// \param[out] error      if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                new stream profile, must be deleted by rs2_delete_stream_profile
    pub fn rs2_clone_stream_profile(
        mode: *const rs2_stream_profile,
        stream: rs2_stream,
        index: ::std::os::raw::c_int,
        format: rs2_format,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_stream_profile;
}
extern "C" {
    /// Creates a copy of stream profile, assigning new values to some of the fields
    /// \param[in] mode        input stream profile
    /// \param[in] stream      stream type for the profile
    /// \param[in] format      binary data format of the profile
    /// \param[in] width       new width for the profile
    /// \param[in] height      new height for the profile
    /// \param[in] intr        new intrinsics for the profile
    /// \param[in] index       stream index the profile in case there are multiple streams of the same type
    /// \param[out] error      if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                new stream profile, must be deleted by rs2_delete_stream_profile
    pub fn rs2_clone_video_stream_profile(
        mode: *const rs2_stream_profile,
        stream: rs2_stream,
        index: ::std::os::raw::c_int,
        format: rs2_format,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        intr: *const rs2_intrinsics,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_stream_profile;
}
extern "C" {
    /// Delete stream profile allocated by rs2_clone_stream_profile
    /// Should not be called on stream profiles returned by the device
    /// \param[in] mode        input stream profile
    pub fn rs2_delete_stream_profile(mode: *mut rs2_stream_profile);
}
extern "C" {
    /// Try to extend stream profile to an extension type
    /// \param[in] mode        input stream profile
    /// \param[in] type        extension type, for example RS2_EXTENSION_VIDEO_STREAM_PROFILE
    /// \param[out] error      if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                non-zero if profile is extendable to specified extension, zero otherwise
    pub fn rs2_stream_profile_is(
        mode: *const rs2_stream_profile,
        type_: rs2_extension,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// When called on a video stream profile, will return the width and the height of the stream
    /// \param[in] mode        input stream profile
    /// \param[out] width      width in pixels of the video stream
    /// \param[out] height     height in pixels of the video stream
    /// \param[out] error      if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_get_video_stream_resolution(
        mode: *const rs2_stream_profile,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Obtain the intrinsics of a specific stream configuration from the device.
    /// \param[in] mode          input stream profile
    /// \param[out] intrinsics   Pointer to the struct to store the data in
    /// \param[out] error        If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_get_motion_intrinsics(
        mode: *const rs2_stream_profile,
        intrinsics: *mut rs2_motion_device_intrinsic,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Returns non-zero if selected profile is recommended for the sensor
    /// This is an optional hint we offer to suggest profiles with best performance-quality tradeof
    /// \param[in] mode        input stream profile
    /// \param[out] error      if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                non-zero if selected profile is recommended for the sensor
    pub fn rs2_is_stream_profile_default(
        mode: *const rs2_stream_profile,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get the number of supported stream profiles
    /// \param[in] list        the list of supported profiles returned by rs2_get_supported_profiles
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return number of supported subdevice profiles
    pub fn rs2_get_stream_profiles_count(
        list: *const rs2_stream_profile_list,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// delete stream profiles list
    /// \param[in] list        the list of supported profiles returned by rs2_get_supported_profiles
    pub fn rs2_delete_stream_profiles_list(list: *mut rs2_stream_profile_list);
}
extern "C" {
    /// \param[in] from          origin stream profile
    /// \param[in] to            target stream profile
    /// \param[out] extrin       extrinsics from origin to target
    /// \param[out] error        if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_get_extrinsics(
        from: *const rs2_stream_profile,
        to: *const rs2_stream_profile,
        extrin: *mut rs2_extrinsics,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// \param[in] from          origin stream profile
    /// \param[in] to            target stream profile
    /// \param[out] extrin       extrinsics from origin to target
    /// \param[out] error        if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_register_extrinsics(
        from: *const rs2_stream_profile,
        to: *const rs2_stream_profile,
        extrin: rs2_extrinsics,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// When called on a video profile, returns the intrinsics of specific stream configuration
    /// \param[in] mode          input stream profile
    /// \param[out] intrinsics   resulting intrinsics for the video profile
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_get_video_stream_intrinsics(
        mode: *const rs2_stream_profile,
        intrinsics: *mut rs2_intrinsics,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Returns the list of recommended processing blocks for a specific sensor.
    /// Order and configuration of the blocks are decided by the sensor
    /// \param[in] sensor          input sensor
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return list of supported sensor recommended processing blocks
    pub fn rs2_get_recommended_processing_blocks(
        sensor: *mut rs2_sensor,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block_list;
}
extern "C" {
    /// Returns specific processing blocks from processing blocks list
    /// \param[in] list           the processing blocks list
    /// \param[in] index          the requested processing block
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return processing block
    pub fn rs2_get_processing_block(
        list: *const rs2_processing_block_list,
        index: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    /// Returns the processing blocks list size
    /// \param[in] list           the processing blocks list
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return the processing block list size
    pub fn rs2_get_recommended_processing_blocks_count(
        list: *const rs2_processing_block_list,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Deletes processing blocks list
    /// \param[in] list list to delete
    pub fn rs2_delete_recommended_processing_blocks(list: *mut rs2_processing_block_list);
}
extern "C" {
    /// Imports a localization map from file to tm2 tracking device
    /// \param[in]  sensor        TM2 position-tracking sensor
    /// \param[in]  lmap_blob     Localization map raw buffer, serialized
    /// \param[in]  blob_size     The buffer's size in bytes
    /// \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                   Non-zero if succeeded, otherwise 0
    pub fn rs2_import_localization_map(
        sensor: *const rs2_sensor,
        lmap_blob: *const ::std::os::raw::c_uchar,
        blob_size: ::std::os::raw::c_uint,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_export_localization_map(
        sensor: *const rs2_sensor,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    /// Create a named location tag
    /// \param[in]  sensor    T2xx position-tracking sensor
    /// \param[in]  guid      Null-terminated string of up to 127 characters
    /// \param[in]  pos       Position in meters, relative to the current tracking session
    /// \param[in]  orient    Quaternion orientation, expressed the the coordinate system of the current tracking session
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               Non-zero if succeeded, otherwise 0
    pub fn rs2_set_static_node(
        sensor: *const rs2_sensor,
        guid: *const ::std::os::raw::c_char,
        pos: rs2_vector,
        orient: rs2_quaternion,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve a named location tag
    /// \param[in]  sensor    T2xx position-tracking sensor
    /// \param[in]  guid      Null-terminated string of up to 127 characters
    /// \param[out] pos       Position in meters of the tagged (stored) location
    /// \param[out] orient    Quaternion orientation of the tagged (stored) location
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               Non-zero if succeeded, otherwise 0
    pub fn rs2_get_static_node(
        sensor: *const rs2_sensor,
        guid: *const ::std::os::raw::c_char,
        pos: *mut rs2_vector,
        orient: *mut rs2_quaternion,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove a named location tag
    /// \param[in]  sensor    T2xx position-tracking sensor
    /// \param[in]  guid      Null-terminated string of up to 127 characters
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               Non-zero if succeeded, otherwise 0
    pub fn rs2_remove_static_node(
        sensor: *const rs2_sensor,
        guid: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Load Wheel odometer settings from host to device
    /// \param[in] odometry_config_buf   odometer configuration/calibration blob serialized from jsom file
    /// \return true on success
    pub fn rs2_load_wheel_odometry_config(
        sensor: *const rs2_sensor,
        odometry_config_buf: *const ::std::os::raw::c_uchar,
        blob_size: ::std::os::raw::c_uint,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Send wheel odometry data for each individual sensor (wheel)
    /// \param[in] wo_sensor_id       - Zero-based index of (wheel) sensor with the same type within device
    /// \param[in] frame_num          - Monotonocally increasing frame number, managed per sensor.
    /// \param[in] translational_velocity   - Translational velocity of the wheel sensor [meter/sec]
    /// \return true on success
    pub fn rs2_send_wheel_odometry(
        sensor: *const rs2_sensor,
        wo_sensor_id: ::std::os::raw::c_char,
        frame_num: ::std::os::raw::c_uint,
        translational_velocity: rs2_vector,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set intrinsics of a given sensor
    /// \param[in] sensor       The RealSense device
    /// \param[in] profile      Target stream profile
    /// \param[in] intrinsics   Intrinsics value to be written to the device
    /// \param[out] error       If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_set_intrinsics(
        sensor: *const rs2_sensor,
        profile: *const rs2_stream_profile,
        intrinsics: *const rs2_intrinsics,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Set extrinsics between two sensors
    /// \param[in]  from_sensor  Origin sensor
    /// \param[in]  from_profile Origin profile
    /// \param[in]  to_sensor    Target sensor
    /// \param[in]  to_profile   Target profile
    /// \param[out] extrinsics   Extrinsics from origin to target
    /// \param[out] error        If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_set_extrinsics(
        from_sensor: *const rs2_sensor,
        from_profile: *const rs2_stream_profile,
        to_sensor: *mut rs2_sensor,
        to_profile: *const rs2_stream_profile,
        extrinsics: *const rs2_extrinsics,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Set motion device intrinsics
    /// \param[in]  sensor       Motion sensor
    /// \param[in]  profile      Motion stream profile
    /// \param[out] intrinsics   Pointer to the struct to store the data in
    /// \param[out] error        If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_set_motion_device_intrinsics(
        sensor: *const rs2_sensor,
        profile: *const rs2_stream_profile,
        intrinsics: *const rs2_motion_device_intrinsic,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Determines number of devices in a list.
    /// \param[in]  info_list The list of connected devices captured using rs2_query_devices
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               Device count
    pub fn rs2_get_device_count(
        info_list: *const rs2_device_list,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Deletes device list, any devices created using this list will remain unaffected.
    /// \param[in]  info_list List to delete
    pub fn rs2_delete_device_list(info_list: *mut rs2_device_list);
}
extern "C" {
    /// Checks if a specific device is contained inside a device list.
    /// \param[in]  info_list The list of devices to check in
    /// \param[in]  device    RealSense device to check for
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               True if the device is in the list and false otherwise
    pub fn rs2_device_list_contains(
        info_list: *const rs2_device_list,
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Creates a device by index. The device object represents a physical camera and provides the means to manipulate it.
    /// \param[in]  info_list the list containing the device to retrieve
    /// \param[in]  index     The zero based index of device to retrieve
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               The requested device, should be released by rs2_delete_device
    pub fn rs2_create_device(
        info_list: *const rs2_device_list,
        index: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device;
}
extern "C" {
    /// Delete RealSense device
    /// \param[in]  device    Realsense device to delete
    pub fn rs2_delete_device(device: *mut rs2_device);
}
extern "C" {
    /// Retrieve camera specific information, like versions of various internal components.
    /// \param[in]  device    The RealSense device
    /// \param[in]  info      Camera info type to retrieve
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               The requested camera info string, in a format specific to the device model
    pub fn rs2_get_device_info(
        device: *const rs2_device,
        info: rs2_camera_info,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Check if a camera supports a specific camera info type.
    /// \param[in]  device    The RealSense device to check
    /// \param[in]  info      The parameter to check for support
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               True if the parameter both exist and well-defined for the specific device
    pub fn rs2_supports_device_info(
        device: *const rs2_device,
        info: rs2_camera_info,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Send hardware reset request to the device. The actual reset is asynchronous.
    /// Note: Invalidates all handles to this device.
    /// \param[in]  device   The RealSense device to reset
    /// \param[out] error    If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_hardware_reset(device: *const rs2_device, error: *mut *mut rs2_error);
}
extern "C" {
    /// Send raw data to device
    /// \param[in]  device                    RealSense device to send data to
    /// \param[in]  raw_data_to_send          Raw data to be sent to device
    /// \param[in]  size_of_raw_data_to_send  Size of raw_data_to_send in bytes
    /// \param[out] error                     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                               Device's response in a rs2_raw_data_buffer, which should be released by rs2_delete_raw_data
    pub fn rs2_send_and_receive_raw_data(
        device: *mut rs2_device,
        raw_data_to_send: *mut ::std::os::raw::c_void,
        size_of_raw_data_to_send: ::std::os::raw::c_uint,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    /// Test if the given device can be extended to the requested extension.
    /// \param[in]  device    Realsense device
    /// \param[in]  extension The extension to which the device should be tested if it is extendable
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               Non-zero value iff the device can be extended to the given extension
    pub fn rs2_is_device_extendable_to(
        device: *const rs2_device,
        extension: rs2_extension,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Create a static snapshot of all connected sensors within a specific device.
    /// \param[in]  device    Specific RealSense device
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               The list of sensors, should be released by rs2_delete_sensor_list
    pub fn rs2_query_sensors(
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_sensor_list;
}
extern "C" {
    /// Enter the given device into loopback operation mode that uses the given file as input for raw data
    /// \param[in]  device     Device to enter into loopback operation mode
    /// \param[in]  from_file  Path to bag file with raw data for loopback
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_loopback_enable(
        device: *const rs2_device,
        from_file: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Restores the given device into normal operation mode
    /// \param[in]  device     Device to restore to normal operation mode
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_loopback_disable(device: *const rs2_device, error: *mut *mut rs2_error);
}
extern "C" {
    /// Checks if the device is in loopback mode or not
    /// \param[in]  device     Device to check for operation mode
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return true if the device is in loopback operation mode
    pub fn rs2_loopback_is_enabled(
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Connects to a given tm2 controller
    /// \param[in]  device     Device to connect to the controller
    /// \param[in]  mac_addr   The MAC address of the desired controller
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_connect_tm2_controller(
        device: *const rs2_device,
        mac_addr: *const ::std::os::raw::c_uchar,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Disconnects a given tm2 controller
    /// \param[in]  device     Device to disconnect the controller from
    /// \param[in]  id         The ID of the desired controller
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_disconnect_tm2_controller(
        device: *const rs2_device,
        id: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Reset device to factory calibration
    /// \param[in] device       The RealSense device
    /// \param[out] error       If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_reset_to_factory_calibration(device: *const rs2_device, e: *mut *mut rs2_error);
}
extern "C" {
    /// Write calibration to device's EEPROM
    /// \param[in] device       The RealSense device
    /// \param[out] error       If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_write_calibration(device: *const rs2_device, e: *mut *mut rs2_error);
}
extern "C" {
    /// Update device to the provided firmware, the device must be extendable to RS2_EXTENSION_UPDATABLE.
    /// This call is executed on the caller's thread and it supports progress notifications via the optional callback.
    /// \param[in]  device        Device to update
    /// \param[in]  fw_image      Firmware image buffer
    /// \param[in]  fw_image_size Firmware image buffer size
    /// \param[in]  callback      Optional callback for update progress notifications, the progress value is normailzed to 1
    /// \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_update_firmware_cpp(
        device: *const rs2_device,
        fw_image: *const ::std::os::raw::c_void,
        fw_image_size: ::std::os::raw::c_int,
        callback: *mut rs2_update_progress_callback,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Update device to the provided firmware, the device must be extendable to RS2_EXTENSION_UPDATABLE.
    /// This call is executed on the caller's thread and it supports progress notifications via the optional callback.
    /// \param[in]  device        Device to update
    /// \param[in]  fw_image      Firmware image buffer
    /// \param[in]  fw_image_size Firmware image buffer size
    /// \param[in]  callback      Optional callback for update progress notifications, the progress value is normailzed to 1
    /// \param[in]  client_data   Optional client data for the callback
    /// \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_update_firmware(
        device: *const rs2_device,
        fw_image: *const ::std::os::raw::c_void,
        fw_image_size: ::std::os::raw::c_int,
        callback: rs2_update_progress_callback_ptr,
        client_data: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Create backup of camera flash memory. Such backup does not constitute valid firmware image, and cannot be
    /// loaded back to the device, but it does contain all calibration and device information.
    /// \param[in]  device        Device to update
    /// \param[in]  callback      Optional callback for update progress notifications, the progress value is normailzed to 1
    /// \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_flash_backup_cpp(
        device: *const rs2_device,
        callback: *mut rs2_update_progress_callback,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    /// Create backup of camera flash memory. Such backup does not constitute valid firmware image, and cannot be
    /// loaded back to the device, but it does contain all calibration and device information.
    /// \param[in]  device        Device to update
    /// \param[in]  callback      Optional callback for update progress notifications, the progress value is normailzed to 1
    /// \param[in]  client_data   Optional client data for the callback
    /// \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_flash_backup(
        device: *const rs2_device,
        callback: rs2_update_progress_callback_ptr,
        client_data: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    /// Update device to the provided firmware by writing raw data directly to the flash, this command can be executed only on unlocked camera.
    /// The device must be extendable to RS2_EXTENSION_UPDATABLE.
    /// This call is executed on the caller's thread and it supports progress notifications via the optional callback.
    /// \param[in]  device        Device to update
    /// \param[in]  fw_image      Firmware image buffer
    /// \param[in]  fw_image_size Firmware image buffer size
    /// \param[in]  callback      Optional callback for update progress notifications, the progress value is normailzed to 1
    /// \param[in]  update_mode   Select one of RS2_UNSIGNED_UPDATE_MODE, WARNING!!! setting to any option other than RS2_UNSIGNED_UPDATE_MODE_UPDATE will make this call unsafe and might damage the camera
    /// \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_update_firmware_unsigned_cpp(
        device: *const rs2_device,
        fw_image: *const ::std::os::raw::c_void,
        fw_image_size: ::std::os::raw::c_int,
        callback: *mut rs2_update_progress_callback,
        update_mode: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Update device to the provided firmware by writing raw data directly to the flash, this command can be executed only on unlocked camera.
    /// The device must be extendable to RS2_EXTENSION_UPDATABLE.
    /// This call is executed on the caller's thread and it supports progress notifications via the optional callback.
    /// \param[in]  device        Device to update
    /// \param[in]  fw_image      Firmware image buffer
    /// \param[in]  fw_image_size Firmware image buffer size
    /// \param[in]  callback      Optional callback for update progress notifications, the progress value is normailzed to 1
    /// \param[in]  client_data   Optional client data for the callback
    /// \param[in]  update_mode   Select one of RS2_UNSIGNED_UPDATE_MODE, WARNING!!! setting to any option other than RS2_UNSIGNED_UPDATE_MODE_UPDATE will make this call unsafe and might damage the camera
    /// \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_update_firmware_unsigned(
        device: *const rs2_device,
        fw_image: *const ::std::os::raw::c_void,
        fw_image_size: ::std::os::raw::c_int,
        callback: rs2_update_progress_callback_ptr,
        client_data: *mut ::std::os::raw::c_void,
        update_mode: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Enter the device to update state, this will cause the updatable device to disconnect and reconnect as update device.
    /// \param[in]  device     Device to update
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_enter_update_state(device: *const rs2_device, error: *mut *mut rs2_error);
}
extern "C" {
    /// This will improve the depth noise.
    /// \param[in] json_content       Json string to configure speed on chip calibration parameters:
    ///{
    ///"speed": 3,
    ///"scan parameter": 0,
    ///"data sampling": 0
    ///}
    ///speed - value can be one of: Very fast = 0, Fast = 1, Medium = 2, Slow = 3, White wall = 4, default is  Slow
    ///scan_parameter - value can be one of: Py scan (default) = 0, Rx scan = 1
    ///data_sampling - value can be one of:polling data sampling = 0, interrupt data sampling = 1
    ///if json is nullptr it will be ignored and calibration will use the default parameters
    /// \param[out] health            Calibration Health-Check captures how far camera calibration is from the optimal one
    ///[0, 0.25) - Good
    ///[0.25, 0.75) - Can be Improved
    ///[0.75, ) - Requires Calibration
    /// \param[in] callback           Optional callback to get progress notifications
    /// \param[in] timeout_ms         Timeout in ms (use 5000 msec unless instructed otherwise)
    /// \return                       New calibration table
    pub fn rs2_run_on_chip_calibration_cpp(
        device: *mut rs2_device,
        json_content: *const ::std::os::raw::c_void,
        content_size: ::std::os::raw::c_int,
        health: *mut f32,
        progress_callback: *mut rs2_update_progress_callback,
        timeout_ms: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    /// This will improve the depth noise.
    /// \param[in] json_content       Json string to configure speed on chip calibration parameters:
    ///{
    ///"speed": 3,
    ///"scan parameter": 0,
    ///"data sampling": 0
    ///}
    ///speed - value can be one of: Very fast = 0, Fast = 1, Medium = 2, Slow = 3, White wall = 4, default is  Slow
    ///scan_parameter - value can be one of: Py scan (default) = 0, Rx scan = 1
    ///data_sampling - value can be one of:polling data sampling = 0, interrupt data sampling = 1
    ///if json is nullptr it will be ignored and calibration will use the default parameters
    /// \param[out] health            Calibration Health-Check captures how far camera calibration is from the optimal one
    ///[0, 0.25) - Good
    ///[0.25, 0.75) - Can be Improved
    ///[0.75, ) - Requires Calibration
    /// \param[in]  callback          Optional callback for update progress notifications, the progress value is normailzed to 1
    /// \param[in]  client_data       Optional client data for the callback
    /// \param[in] timeout_ms         Timeout in ms (use 5000 msec unless instructed otherwise)
    /// \return                       New calibration table
    pub fn rs2_run_on_chip_calibration(
        device: *mut rs2_device,
        json_content: *const ::std::os::raw::c_void,
        content_size: ::std::os::raw::c_int,
        health: *mut f32,
        callback: rs2_update_progress_callback_ptr,
        client_data: *mut ::std::os::raw::c_void,
        timeout_ms: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    /// This will adjust camera absolute distance to flat target. User needs to enter the known ground truth.
    /// \param[in] ground_truth_mm     Ground truth in mm must be between 2500 - 2000000
    /// \param[in] json_content        Json string to configure tare calibration parameters:
    ///{
    ///"average step count": 20,
    ///"step count": 20,
    ///"accuracy": 2,
    ///"scan parameter": 0,
    ///"data sampling": 0
    ///}
    ///average step count - number of frames to average, must be between 1 - 30, default = 20
    ///step count - max iteration steps, must be between 5 - 30, default = 10
    ///accuracy - Subpixel accuracy level, value can be one of: Very high = 0 (0.025%), High = 1 (0.05%), Medium = 2 (0.1%), Low = 3 (0.2%), Default = Very high (0.025%), default is very high (0.025%)
    ///scan_parameter - value can be one of: Py scan (default) = 0, Rx scan = 1
    ///data_sampling - value can be one of:polling data sampling = 0, interrupt data sampling = 1
    ///if json is nullptr it will be ignored and calibration will use the default parameters
    /// \param[in]  content_size        Json string size if its 0 the json will be ignored and calibration will use the default parameters
    /// \param[in]  callback            Optional callback to get progress notifications
    /// \param[in] timeout_ms          Timeout in ms (use 5000 msec unless instructed otherwise)
    /// \return                         New calibration table
    pub fn rs2_run_tare_calibration_cpp(
        dev: *mut rs2_device,
        ground_truth_mm: f32,
        json_content: *const ::std::os::raw::c_void,
        content_size: ::std::os::raw::c_int,
        progress_callback: *mut rs2_update_progress_callback,
        timeout_ms: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    /// This will adjust camera absolute distance to flat target. User needs to enter the known ground truth.
    /// \param[in] ground_truth_mm     Ground truth in mm must be between 2500 - 2000000
    /// \param[in] json_content        Json string to configure tare calibration parameters:
    ///{
    ///"average_step_count": 20,
    ///"step count": 20,
    ///"accuracy": 2,
    ///"scan parameter": 0,
    ///"data sampling": 0
    ///}
    ///average step count - number of frames to average, must be between 1 - 30, default = 20
    ///step count - max iteration steps, must be between 5 - 30, default = 10
    ///accuracy - Subpixel accuracy level, value can be one of: Very high = 0 (0.025%), High = 1 (0.05%), Medium = 2 (0.1%), Low = 3 (0.2%), Default = Very high (0.025%), default is very high (0.025%)
    ///scan_parameter - value can be one of: Py scan (default) = 0, Rx scan = 1
    ///data_sampling - value can be one of:polling data sampling = 0, interrupt data sampling = 1
    ///if json is nullptr it will be ignored and calibration will use the default parameters
    /// \param[in]  content_size       Json string size if its 0 the json will be ignored and calibration will use the default parameters
    /// \param[in]  callback           Optional callback for update progress notifications, the progress value is normailzed to 1
    /// \param[in]  client_data        Optional client data for the callback
    /// \param[in] timeout_ms          Timeout in ms (use 5000 msec unless instructed otherwise)
    /// \return                        New calibration table
    pub fn rs2_run_tare_calibration(
        dev: *mut rs2_device,
        ground_truth_mm: f32,
        json_content: *const ::std::os::raw::c_void,
        content_size: ::std::os::raw::c_int,
        callback: rs2_update_progress_callback_ptr,
        client_data: *mut ::std::os::raw::c_void,
        timeout_ms: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    ///  Read current calibration table from flash.
    /// \return    Calibration table
    pub fn rs2_get_calibration_table(
        dev: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> *const rs2_raw_data_buffer;
}
extern "C" {
    ///  Set current table to dynamic area.
    /// \param[in]     Calibration table
    pub fn rs2_set_calibration_table(
        device: *const rs2_device,
        calibration: *const ::std::os::raw::c_void,
        calibration_size: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
///< Frame timestamp was measured in relation to the camera clock
pub const rs2_timestamp_domain_RS2_TIMESTAMP_DOMAIN_HARDWARE_CLOCK: rs2_timestamp_domain = 0;
///< Frame timestamp was measured in relation to the OS system clock
pub const rs2_timestamp_domain_RS2_TIMESTAMP_DOMAIN_SYSTEM_TIME: rs2_timestamp_domain = 1;
///< Frame timestamp was measured in relation to the camera clock and converted to OS system clock by constantly measure the difference
pub const rs2_timestamp_domain_RS2_TIMESTAMP_DOMAIN_GLOBAL_TIME: rs2_timestamp_domain = 2;
///< Number of enumeration values. Not a valid input: intended to be used in for-loops.
pub const rs2_timestamp_domain_RS2_TIMESTAMP_DOMAIN_COUNT: rs2_timestamp_domain = 3;
/// \brief Specifies the clock in relation to which the frame timestamp was measured.
pub type rs2_timestamp_domain = u32;
extern "C" {
    pub fn rs2_timestamp_domain_to_string(
        info: rs2_timestamp_domain,
    ) -> *const ::std::os::raw::c_char;
}
///< A sequential index managed per-stream. Integer value
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_FRAME_COUNTER: rs2_frame_metadata_value = 0;
///< Timestamp set by device clock when data readout and transmit commence. usec
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_FRAME_TIMESTAMP: rs2_frame_metadata_value = 1;
///< Timestamp of the middle of sensor's exposure calculated by device. usec
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_SENSOR_TIMESTAMP: rs2_frame_metadata_value =
    2;
///< Sensor's exposure width. When Auto Exposure (AE) is on the value is controlled by firmware. usec
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_ACTUAL_EXPOSURE: rs2_frame_metadata_value = 3;
///< A relative value increasing which will increase the Sensor's gain factor. \
///When AE is set On, the value is controlled by firmware. Integer value
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_GAIN_LEVEL: rs2_frame_metadata_value = 4;
///< Auto Exposure Mode indicator. Zero corresponds to AE switched off.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_AUTO_EXPOSURE: rs2_frame_metadata_value = 5;
///< White Balance setting as a color temperature. Kelvin degrees
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_WHITE_BALANCE: rs2_frame_metadata_value = 6;
///< Time of arrival in system clock
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_TIME_OF_ARRIVAL: rs2_frame_metadata_value = 7;
///< Temperature of the device, measured at the time of the frame capture. Celsius degrees
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_TEMPERATURE: rs2_frame_metadata_value = 8;
///< Timestamp get from uvc driver. usec
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_BACKEND_TIMESTAMP: rs2_frame_metadata_value =
    9;
///< Actual fps
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_ACTUAL_FPS: rs2_frame_metadata_value = 10;
///< Laser power value 0-360.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_FRAME_LASER_POWER: rs2_frame_metadata_value =
    11;
///< Laser power mode. Zero corresponds to Laser power switched off and one for switched on. deprecated, replaced by RS2_FRAME_METADATA_FRAME_EMITTER_MODE
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_FRAME_LASER_POWER_MODE:
    rs2_frame_metadata_value = 12;
///< Exposure priority.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_EXPOSURE_PRIORITY: rs2_frame_metadata_value =
    13;
///< Left region of interest for the auto exposure Algorithm.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_EXPOSURE_ROI_LEFT: rs2_frame_metadata_value =
    14;
///< Right region of interest for the auto exposure Algorithm.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_EXPOSURE_ROI_RIGHT: rs2_frame_metadata_value =
    15;
///< Top region of interest for the auto exposure Algorithm.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_EXPOSURE_ROI_TOP: rs2_frame_metadata_value =
    16;
///< Bottom region of interest for the auto exposure Algorithm.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_EXPOSURE_ROI_BOTTOM:
    rs2_frame_metadata_value = 17;
///< Color image brightness.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_BRIGHTNESS: rs2_frame_metadata_value = 18;
///< Color image contrast.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_CONTRAST: rs2_frame_metadata_value = 19;
///< Color image saturation.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_SATURATION: rs2_frame_metadata_value = 20;
///< Color image sharpness.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_SHARPNESS: rs2_frame_metadata_value = 21;
///< Auto white balance temperature Mode indicator. Zero corresponds to automatic mode switched off.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_AUTO_WHITE_BALANCE_TEMPERATURE:
    rs2_frame_metadata_value = 22;
///< Color backlight compensation. Zero corresponds to switched off.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_BACKLIGHT_COMPENSATION:
    rs2_frame_metadata_value = 23;
///< Color image hue.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_HUE: rs2_frame_metadata_value = 24;
///< Color image gamma.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_GAMMA: rs2_frame_metadata_value = 25;
///< Color image white balance.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_MANUAL_WHITE_BALANCE:
    rs2_frame_metadata_value = 26;
///< Power Line Frequency for anti-flickering Off/50Hz/60Hz/Auto.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_POWER_LINE_FREQUENCY:
    rs2_frame_metadata_value = 27;
///< Color lowlight compensation. Zero corresponds to switched off.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_LOW_LIGHT_COMPENSATION:
    rs2_frame_metadata_value = 28;
///< Emitter mode: 0 - all emitters disabled. 1 - laser enabled. 2 - auto laser enabled (opt). 3 - LED enabled (opt).
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_FRAME_EMITTER_MODE: rs2_frame_metadata_value =
    29;
///< Led power value 0-360.
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_FRAME_LED_POWER: rs2_frame_metadata_value =
    30;
///< The number of transmitted payload bytes, not including metadata
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_RAW_FRAME_SIZE: rs2_frame_metadata_value = 31;
pub const rs2_frame_metadata_value_RS2_FRAME_METADATA_COUNT: rs2_frame_metadata_value = 32;
/// \brief Per-Frame-Metadata is the set of read-only properties that might be exposed for each individual frame.
pub type rs2_frame_metadata_value = u32;
extern "C" {
    pub fn rs2_frame_metadata_to_string(
        metadata: rs2_frame_metadata_value,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rs2_frame_metadata_value_to_string(
        metadata: rs2_frame_metadata_value,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// retrieve metadata from frame handle
    /// \param[in] frame      handle returned from a callback
    /// \param[in] frame_metadata  the rs2_frame_metadata whose latest frame we are interested in
    /// \param[out] error         if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return            the metadata value
    pub fn rs2_get_frame_metadata(
        frame: *const rs2_frame,
        frame_metadata: rs2_frame_metadata_value,
        error: *mut *mut rs2_error,
    ) -> rs2_metadata_type;
}
extern "C" {
    /// determine device metadata
    /// \param[in] frame             handle returned from a callback
    /// \param[in] frame_metadata    the metadata to check for support
    /// \param[out] error         if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                true if device has this metadata
    pub fn rs2_supports_frame_metadata(
        frame: *const rs2_frame,
        frame_metadata: rs2_frame_metadata_value,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// retrieve timestamp domain from frame handle. timestamps can only be comparable if they are in common domain
    /// (for example, depth timestamp might come from system time while color timestamp might come from the device)
    /// this method is used to check if two timestamp values are comparable (generated from the same clock)
    /// \param[in] frameset   handle returned from a callback
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               the timestamp domain of the frame (camera / microcontroller / system time)
    pub fn rs2_get_frame_timestamp_domain(
        frameset: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> rs2_timestamp_domain;
}
extern "C" {
    /// retrieve timestamp from frame handle in milliseconds
    /// \param[in] frame      handle returned from a callback
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               the timestamp of the frame in milliseconds
    pub fn rs2_get_frame_timestamp(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> rs2_time_t;
}
extern "C" {
    /// retrieve frame parent sensor from frame handle
    /// \param[in] frame      handle returned from a callback
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               the parent sensor of the frame
    pub fn rs2_get_frame_sensor(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_sensor;
}
extern "C" {
    /// retrieve frame number from frame handle
    /// \param[in] frame      handle returned from a callback
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               the frame nubmer of the frame, in milliseconds since the device was started
    pub fn rs2_get_frame_number(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    /// retrieve data size from frame handle
    /// \param[in] frame      handle returned from a callback
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               the size of the frame data
    pub fn rs2_get_frame_data_size(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// retrieve data from frame handle
    /// \param[in] frame      handle returned from a callback
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               the pointer to the start of the frame data
    pub fn rs2_get_frame_data(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    /// retrieve frame width in pixels
    /// \param[in] frame      handle returned from a callback
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               frame width in pixels
    pub fn rs2_get_frame_width(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// retrieve frame height in pixels
    /// \param[in] frame      handle returned from a callback
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               frame height in pixels
    pub fn rs2_get_frame_height(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// retrieve frame stride in bytes (number of bytes from start of line N to start of line N+1)
    /// \param[in] frame      handle returned from a callback
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               stride in bytes
    pub fn rs2_get_frame_stride_in_bytes(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// retrieve bits per pixels in the frame image
    /// (note that bits per pixel is not necessarily divided by 8, as in 12bpp)
    /// \param[in] frame      handle returned from a callback
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               bits per pixel
    pub fn rs2_get_frame_bits_per_pixel(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// create additional reference to a frame without duplicating frame data
    /// \param[in] frame      handle returned from a callback
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               new frame reference, has to be released by rs2_release_frame
    pub fn rs2_frame_add_ref(frame: *mut rs2_frame, error: *mut *mut rs2_error);
}
extern "C" {
    /// relases the frame handle
    /// \param[in] frame handle returned from a callback
    pub fn rs2_release_frame(frame: *mut rs2_frame);
}
extern "C" {
    /// communicate to the library you intend to keep the frame alive for a while
    /// this will remove the frame from the regular count of the frame pool
    /// once this function is called, the SDK can no longer guarantee 0-allocations during frame cycling
    /// \param[in] frame handle returned from a callback
    pub fn rs2_keep_frame(frame: *mut rs2_frame);
}
extern "C" {
    /// When called on Points frame type, this method returns a pointer to an array of 3D vertices of the model
    /// The coordinate system is: X right, Y up, Z away from the camera. Units: Meters
    /// \param[in] frame       Points frame
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                Pointer to an array of vertices, lifetime is managed by the frame
    pub fn rs2_get_frame_vertices(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_vertex;
}
extern "C" {
    /// When called on Points frame type, this method creates a ply file of the model with the given file name.
    /// \param[in] frame       Points frame
    /// \param[in] fname       The name for the ply file
    /// \param[in] texture     Texture frame
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_export_to_ply(
        frame: *const rs2_frame,
        fname: *const ::std::os::raw::c_char,
        texture: *mut rs2_frame,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// When called on Points frame type, this method returns a pointer to an array of texture coordinates per vertex
    /// Each coordinate represent a (u,v) pair within [0,1] range, to be mapped to texture image
    /// \param[in] frame       Points frame
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                Pointer to an array of texture coordinates, lifetime is managed by the frame
    pub fn rs2_get_frame_texture_coordinates(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pixel;
}
extern "C" {
    /// When called on Points frame type, this method returns the number of vertices in the frame
    /// \param[in] frame       Points frame
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                Number of vertices
    pub fn rs2_get_frame_points_count(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Returns the stream profile that was used to start the stream of this frame
    /// \param[in] frame       frame reference, owned by the user
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                Pointer to the stream profile object, lifetime is managed elsewhere
    pub fn rs2_get_frame_stream_profile(
        frame: *const rs2_frame,
        error: *mut *mut rs2_error,
    ) -> *const rs2_stream_profile;
}
extern "C" {
    /// Test if the given frame can be extended to the requested extension
    /// \param[in]  frame             Realsense frame
    /// \param[in]  extension_type    The extension to which the frame should be tested if it is extendable
    /// \param[out] error             If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return non-zero value iff the frame can be extended to the given extension
    pub fn rs2_is_frame_extendable_to(
        frame: *const rs2_frame,
        extension_type: rs2_extension,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Allocate new video frame using a frame-source provided form a processing block
    /// \param[in] source      Frame pool to allocate the frame from
    /// \param[in] new_stream  New stream profile to assign to newly created frame
    /// \param[in] original    A reference frame that can be used to fill in auxilary information like format, width, height, bpp, stride (if applicable)
    /// \param[in] new_bpp     New value for bits per pixel for the allocated frame
    /// \param[in] new_width   New value for width for the allocated frame
    /// \param[in] new_height  New value for height for the allocated frame
    /// \param[in] new_stride  New value for stride in bytes for the allocated frame
    /// \param[in] frame_type  New value for frame type for the allocated frame
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                reference to a newly allocated frame, must be released with release_frame
    ///                        memory for the frame is likely to be re-used from previous frame, but in lack of available frames in the pool will be allocated from the free store
    pub fn rs2_allocate_synthetic_video_frame(
        source: *mut rs2_source,
        new_stream: *const rs2_stream_profile,
        original: *mut rs2_frame,
        new_bpp: ::std::os::raw::c_int,
        new_width: ::std::os::raw::c_int,
        new_height: ::std::os::raw::c_int,
        new_stride: ::std::os::raw::c_int,
        frame_type: rs2_extension,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_frame;
}
extern "C" {
    /// Allocate new motion frame using a frame-source provided form a processing block
    /// \param[in] source      Frame pool to allocate the frame from
    /// \param[in] new_stream  New stream profile to assign to newly created frame
    /// \param[in] original    A reference frame that can be used to fill in auxilary information like format, width, height, bpp, stride (if applicable)
    /// \param[in] frame_type  New value for frame type for the allocated frame
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                reference to a newly allocated frame, must be released with release_frame
    ///                        memory for the frame is likely to be re-used from previous frame, but in lack of available frames in the pool will be allocated from the free store
    pub fn rs2_allocate_synthetic_motion_frame(
        source: *mut rs2_source,
        new_stream: *const rs2_stream_profile,
        original: *mut rs2_frame,
        frame_type: rs2_extension,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_frame;
}
extern "C" {
    /// Allocate new points frame using a frame-source provided from a processing block
    /// \param[in] source      Frame pool to allocate the frame from
    /// \param[in] new_stream  New stream profile to assign to newly created frame
    /// \param[in] original    A reference frame that can be used to fill in auxilary information like format, width, height, bpp, stride (if applicable)
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                reference to a newly allocated frame, must be released with release_frame
    ///                        memory for the frame is likely to be re-used from previous frame, but in lack of available frames in the pool will be allocated from the free store
    pub fn rs2_allocate_points(
        source: *mut rs2_source,
        new_stream: *const rs2_stream_profile,
        original: *mut rs2_frame,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_frame;
}
extern "C" {
    /// Allocate new composite frame, aggregating a set of existing frames
    /// \param[in] source      Frame pool to allocate the frame from
    /// \param[in] frames      Array of existing frames
    /// \param[in] count       Number of input frames
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                reference to a newly allocated frame, must be released with release_frame
    ///                        when composite frame gets released it will automatically release all of the input frames
    pub fn rs2_allocate_composite_frame(
        source: *mut rs2_source,
        frames: *mut *mut rs2_frame,
        count: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_frame;
}
extern "C" {
    /// Extract frame from within a composite frame
    /// \param[in] composite   Composite frame
    /// \param[in] index       Index of the frame to extract within the composite frame
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                returns reference to a frame existing within the composite frame
    ///                        If you wish to keep this frame after the composite is released, you need to call acquire_ref
    ///                        Otherwise the resulting frame lifetime is bound by owning composite frame
    pub fn rs2_extract_frame(
        composite: *mut rs2_frame,
        index: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_frame;
}
extern "C" {
    /// Get number of frames embedded within a composite frame
    /// \param[in] composite   Composite input frame
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return                Number of embedded frames
    pub fn rs2_embedded_frames_count(
        composite: *mut rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This method will dispatch frame callback on a frame
    /// \param[in] source      Frame pool provided by the processing block
    /// \param[in] frame       Frame to dispatch, frame ownership is passed to this function, so you don't have to call release_frame after it
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_synthetic_frame_ready(
        source: *mut rs2_source,
        frame: *mut rs2_frame,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// When called on Pose frame type, this method returns the transformation represented by the pose data
    /// \param[in] frame       Pose frame
    /// \param[out] pose       Pointer to a user allocated struct, which contains the pose info after a successful return
    /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_pose_frame_get_pose_data(
        frame: *const rs2_frame,
        pose: *mut rs2_pose,
        error: *mut *mut rs2_error,
    );
}
///< Enable / disable color backlight compensation
pub const rs2_option_RS2_OPTION_BACKLIGHT_COMPENSATION: rs2_option = 0;
///< Color image brightness
pub const rs2_option_RS2_OPTION_BRIGHTNESS: rs2_option = 1;
///< Color image contrast
pub const rs2_option_RS2_OPTION_CONTRAST: rs2_option = 2;
///< Controls exposure time of color camera. Setting any value will disable auto exposure
pub const rs2_option_RS2_OPTION_EXPOSURE: rs2_option = 3;
///< Color image gain
pub const rs2_option_RS2_OPTION_GAIN: rs2_option = 4;
///< Color image gamma setting
pub const rs2_option_RS2_OPTION_GAMMA: rs2_option = 5;
///< Color image hue
pub const rs2_option_RS2_OPTION_HUE: rs2_option = 6;
///< Color image saturation setting
pub const rs2_option_RS2_OPTION_SATURATION: rs2_option = 7;
///< Color image sharpness setting
pub const rs2_option_RS2_OPTION_SHARPNESS: rs2_option = 8;
///< Controls white balance of color image. Setting any value will disable auto white balance
pub const rs2_option_RS2_OPTION_WHITE_BALANCE: rs2_option = 9;
///< Enable / disable color image auto-exposure
pub const rs2_option_RS2_OPTION_ENABLE_AUTO_EXPOSURE: rs2_option = 10;
///< Enable / disable color image auto-white-balance
pub const rs2_option_RS2_OPTION_ENABLE_AUTO_WHITE_BALANCE: rs2_option = 11;
///< Provide access to several recommend sets of option presets for the depth camera
pub const rs2_option_RS2_OPTION_VISUAL_PRESET: rs2_option = 12;
///< Power of the laser emitter, with 0 meaning projector off
pub const rs2_option_RS2_OPTION_LASER_POWER: rs2_option = 13;
///< Set the number of patterns projected per frame. The higher the accuracy value the more patterns projected. Increasing the number of patterns help to achieve better accuracy. Note that this control is affecting the Depth FPS
pub const rs2_option_RS2_OPTION_ACCURACY: rs2_option = 14;
///< Motion vs. Range trade-off, with lower values allowing for better motion sensitivity and higher values allowing for better depth range
pub const rs2_option_RS2_OPTION_MOTION_RANGE: rs2_option = 15;
///< Set the filter to apply to each depth frame. Each one of the filter is optimized per the application requirements
pub const rs2_option_RS2_OPTION_FILTER_OPTION: rs2_option = 16;
///< The confidence level threshold used by the Depth algorithm pipe to set whether a pixel will get a valid range or will be marked with invalid range
pub const rs2_option_RS2_OPTION_CONFIDENCE_THRESHOLD: rs2_option = 17;
///< Emitter select: 0 � disable all emitters. 1 � enable laser. 2 � enable auto laser. 3 � enable LED.
pub const rs2_option_RS2_OPTION_EMITTER_ENABLED: rs2_option = 18;
///< Number of frames the user is allowed to keep per stream. Trying to hold-on to more frames will cause frame-drops.
pub const rs2_option_RS2_OPTION_FRAMES_QUEUE_SIZE: rs2_option = 19;
///< Total number of detected frame drops from all streams
pub const rs2_option_RS2_OPTION_TOTAL_FRAME_DROPS: rs2_option = 20;
///< Auto-Exposure modes: Static, Anti-Flicker and Hybrid
pub const rs2_option_RS2_OPTION_AUTO_EXPOSURE_MODE: rs2_option = 21;
///< Power Line Frequency control for anti-flickering Off/50Hz/60Hz/Auto
pub const rs2_option_RS2_OPTION_POWER_LINE_FREQUENCY: rs2_option = 22;
///< Current Asic Temperature
pub const rs2_option_RS2_OPTION_ASIC_TEMPERATURE: rs2_option = 23;
///< disable error handling
pub const rs2_option_RS2_OPTION_ERROR_POLLING_ENABLED: rs2_option = 24;
///< Current Projector Temperature
pub const rs2_option_RS2_OPTION_PROJECTOR_TEMPERATURE: rs2_option = 25;
///< Enable / disable trigger to be outputed from the camera to any external device on every depth frame
pub const rs2_option_RS2_OPTION_OUTPUT_TRIGGER_ENABLED: rs2_option = 26;
///< Current Motion-Module Temperature
pub const rs2_option_RS2_OPTION_MOTION_MODULE_TEMPERATURE: rs2_option = 27;
///< Number of meters represented by a single depth unit
pub const rs2_option_RS2_OPTION_DEPTH_UNITS: rs2_option = 28;
///< Enable/Disable automatic correction of the motion data
pub const rs2_option_RS2_OPTION_ENABLE_MOTION_CORRECTION: rs2_option = 29;
///< Allows sensor to dynamically ajust the frame rate depending on lighting conditions
pub const rs2_option_RS2_OPTION_AUTO_EXPOSURE_PRIORITY: rs2_option = 30;
///< Color scheme for data visualization
pub const rs2_option_RS2_OPTION_COLOR_SCHEME: rs2_option = 31;
///< Perform histogram equalization post-processing on the depth data
pub const rs2_option_RS2_OPTION_HISTOGRAM_EQUALIZATION_ENABLED: rs2_option = 32;
///< Minimal distance to the target
pub const rs2_option_RS2_OPTION_MIN_DISTANCE: rs2_option = 33;
///< Maximum distance to the target
pub const rs2_option_RS2_OPTION_MAX_DISTANCE: rs2_option = 34;
///< Texture mapping stream unique ID
pub const rs2_option_RS2_OPTION_TEXTURE_SOURCE: rs2_option = 35;
///< The 2D-filter effect. The specific interpretation is given within the context of the filter
pub const rs2_option_RS2_OPTION_FILTER_MAGNITUDE: rs2_option = 36;
///< 2D-filter parameter controls the weight/radius for smoothing.
pub const rs2_option_RS2_OPTION_FILTER_SMOOTH_ALPHA: rs2_option = 37;
///< 2D-filter range/validity threshold
pub const rs2_option_RS2_OPTION_FILTER_SMOOTH_DELTA: rs2_option = 38;
///< Enhance depth data post-processing with holes filling where appropriate
pub const rs2_option_RS2_OPTION_HOLES_FILL: rs2_option = 39;
///< The distance in mm between the first and the second imagers in stereo-based depth cameras
pub const rs2_option_RS2_OPTION_STEREO_BASELINE: rs2_option = 40;
///< Allows dynamically ajust the converge step value of the target exposure in Auto-Exposure algorithm
pub const rs2_option_RS2_OPTION_AUTO_EXPOSURE_CONVERGE_STEP: rs2_option = 41;
///< Impose Inter-camera HW synchronization mode. Applicable for D400/Rolling Shutter SKUs
pub const rs2_option_RS2_OPTION_INTER_CAM_SYNC_MODE: rs2_option = 42;
///< Select a stream to process
pub const rs2_option_RS2_OPTION_STREAM_FILTER: rs2_option = 43;
///< Select a stream format to process
pub const rs2_option_RS2_OPTION_STREAM_FORMAT_FILTER: rs2_option = 44;
///< Select a stream index to process
pub const rs2_option_RS2_OPTION_STREAM_INDEX_FILTER: rs2_option = 45;
///< When supported, this option make the camera to switch the emitter state every frame. 0 for disabled, 1 for enabled
pub const rs2_option_RS2_OPTION_EMITTER_ON_OFF: rs2_option = 46;
///< Zero order point x
pub const rs2_option_RS2_OPTION_ZERO_ORDER_POINT_X: rs2_option = 47;
///< Zero order point y
pub const rs2_option_RS2_OPTION_ZERO_ORDER_POINT_Y: rs2_option = 48;
///< LLD temperature
pub const rs2_option_RS2_OPTION_LLD_TEMPERATURE: rs2_option = 49;
///< MC temperature
pub const rs2_option_RS2_OPTION_MC_TEMPERATURE: rs2_option = 50;
///< MA temperature
pub const rs2_option_RS2_OPTION_MA_TEMPERATURE: rs2_option = 51;
///< Hardware stream configuration
pub const rs2_option_RS2_OPTION_HARDWARE_PRESET: rs2_option = 52;
///< disable global time
pub const rs2_option_RS2_OPTION_GLOBAL_TIME_ENABLED: rs2_option = 53;
///< APD temperature
pub const rs2_option_RS2_OPTION_APD_TEMPERATURE: rs2_option = 54;
///< Enable an internal map
pub const rs2_option_RS2_OPTION_ENABLE_MAPPING: rs2_option = 55;
///< Enable appearance based relocalization
pub const rs2_option_RS2_OPTION_ENABLE_RELOCALIZATION: rs2_option = 56;
///< Enable position jumping
pub const rs2_option_RS2_OPTION_ENABLE_POSE_JUMPING: rs2_option = 57;
///< Enable dynamic calibration
pub const rs2_option_RS2_OPTION_ENABLE_DYNAMIC_CALIBRATION: rs2_option = 58;
///< Offset from sensor to depth origin in millimetrers
pub const rs2_option_RS2_OPTION_DEPTH_OFFSET: rs2_option = 59;
///< Power of the LED (light emitting diode), with 0 meaning LED off
pub const rs2_option_RS2_OPTION_LED_POWER: rs2_option = 60;
///< Toggle Zero-Order mode
pub const rs2_option_RS2_OPTION_ZERO_ORDER_ENABLED: rs2_option = 61;
///< Preserve previous map when starting
pub const rs2_option_RS2_OPTION_ENABLE_MAP_PRESERVATION: rs2_option = 62;
///< Number of enumeration values. Not a valid input: intended to be used in for-loops.
pub const rs2_option_RS2_OPTION_COUNT: rs2_option = 63;
/// \brief Defines general configuration controls.
///These can generally be mapped to camera UVC controls, and can be set / queried at any time unless stated otherwise.
pub type rs2_option = u32;
extern "C" {
    pub fn rs2_option_to_string(option: rs2_option) -> *const ::std::os::raw::c_char;
}
///< Preset for short range
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_SHORT_RANGE: rs2_sr300_visual_preset = 0;
///< Preset for long range
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_LONG_RANGE: rs2_sr300_visual_preset = 1;
///< Preset for background segmentation
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_BACKGROUND_SEGMENTATION:
    rs2_sr300_visual_preset = 2;
///< Preset for gesture recognition
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_GESTURE_RECOGNITION:
    rs2_sr300_visual_preset = 3;
///< Preset for object scanning
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_OBJECT_SCANNING: rs2_sr300_visual_preset =
    4;
///< Preset for face analytics
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_FACE_ANALYTICS: rs2_sr300_visual_preset =
    5;
///< Preset for face login
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_FACE_LOGIN: rs2_sr300_visual_preset = 6;
///< Preset for GR cursor
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_GR_CURSOR: rs2_sr300_visual_preset = 7;
///< Camera default settings
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_DEFAULT: rs2_sr300_visual_preset = 8;
///< Preset for mid-range
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_MID_RANGE: rs2_sr300_visual_preset = 9;
///< Preset for IR only
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_IR_ONLY: rs2_sr300_visual_preset = 10;
///< Number of enumeration values. Not a valid input: intended to be used in for-loops.
pub const rs2_sr300_visual_preset_RS2_SR300_VISUAL_PRESET_COUNT: rs2_sr300_visual_preset = 11;
/// \brief For SR300 devices: provides optimized settings (presets) for specific types of usage.
pub type rs2_sr300_visual_preset = u32;
extern "C" {
    pub fn rs2_sr300_visual_preset_to_string(
        preset: rs2_sr300_visual_preset,
    ) -> *const ::std::os::raw::c_char;
}
pub const rs2_rs400_visual_preset_RS2_RS400_VISUAL_PRESET_CUSTOM: rs2_rs400_visual_preset = 0;
pub const rs2_rs400_visual_preset_RS2_RS400_VISUAL_PRESET_DEFAULT: rs2_rs400_visual_preset = 1;
pub const rs2_rs400_visual_preset_RS2_RS400_VISUAL_PRESET_HAND: rs2_rs400_visual_preset = 2;
pub const rs2_rs400_visual_preset_RS2_RS400_VISUAL_PRESET_HIGH_ACCURACY: rs2_rs400_visual_preset =
    3;
pub const rs2_rs400_visual_preset_RS2_RS400_VISUAL_PRESET_HIGH_DENSITY: rs2_rs400_visual_preset = 4;
pub const rs2_rs400_visual_preset_RS2_RS400_VISUAL_PRESET_MEDIUM_DENSITY: rs2_rs400_visual_preset =
    5;
pub const rs2_rs400_visual_preset_RS2_RS400_VISUAL_PRESET_REMOVE_IR_PATTERN:
    rs2_rs400_visual_preset = 6;
pub const rs2_rs400_visual_preset_RS2_RS400_VISUAL_PRESET_COUNT: rs2_rs400_visual_preset = 7;
/// \brief For RS400 devices: provides optimized settings (presets) for specific types of usage.
pub type rs2_rs400_visual_preset = u32;
extern "C" {
    pub fn rs2_rs400_visual_preset_to_string(
        preset: rs2_rs400_visual_preset,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// check if an option is read-only
    /// \param[in] sensor   the RealSense sensor
    /// \param[in] option   option id to be checked
    /// \param[out] error   if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return true if option is read-only
    pub fn rs2_is_option_read_only(
        options: *const rs2_options,
        option: rs2_option,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// read option value from the sensor
    /// \param[in] sensor   the RealSense sensor
    /// \param[in] option   option id to be queried
    /// \param[out] error   if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return value of the option
    pub fn rs2_get_option(
        options: *const rs2_options,
        option: rs2_option,
        error: *mut *mut rs2_error,
    ) -> f32;
}
extern "C" {
    /// write new value to sensor option
    /// \param[in] sensor     the RealSense sensor
    /// \param[in] option     option id to be queried
    /// \param[in] value      new value for the option
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_set_option(
        options: *const rs2_options,
        option: rs2_option,
        value: f32,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// get the list of supported options of options container
    /// \param[in] options    the options container
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_get_options_list(
        options: *const rs2_options,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_options_list;
}
extern "C" {
    /// get the size of options list
    /// \param[in] options    the option list
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_get_options_list_size(
        options: *const rs2_options_list,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// get option name
    /// \param[in] options     options object
    /// \param[in] option      option id to be checked
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return human-readable option name
    pub fn rs2_get_option_name(
        options: *const rs2_options,
        option: rs2_option,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// get the specific option from options list
    /// \param[in] i    the index of the option
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_get_option_from_list(
        options: *const rs2_options_list,
        i: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> rs2_option;
}
extern "C" {
    /// Deletes options list
    /// \param[in] list list to delete
    pub fn rs2_delete_options_list(list: *mut rs2_options_list);
}
extern "C" {
    /// check if particular option is supported by a subdevice
    /// \param[in] sensor     the RealSense sensor
    /// \param[in] option     option id to be checked
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return true if option is supported
    pub fn rs2_supports_option(
        options: *const rs2_options,
        option: rs2_option,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// retrieve the available range of values of a supported option
    /// \param[in] sensor  the RealSense device
    /// \param[in] option  the option whose range should be queried
    /// \param[out] min    the minimum value which will be accepted for this option
    /// \param[out] max    the maximum value which will be accepted for this option
    /// \param[out] step   the granularity of options which accept discrete values, or zero if the option accepts continuous values
    /// \param[out] def    the default value of the option
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_get_option_range(
        sensor: *const rs2_options,
        option: rs2_option,
        min: *mut f32,
        max: *mut f32,
        step: *mut f32,
        def: *mut f32,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// get option description
    /// \param[in] sensor     the RealSense sensor
    /// \param[in] option     option id to be checked
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return human-readable option description
    pub fn rs2_get_option_description(
        options: *const rs2_options,
        option: rs2_option,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// get option value description (in case specific option value hold special meaning)
    /// \param[in] device     the RealSense device
    /// \param[in] option     option id to be checked
    /// \param[in] value      value of the option
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return human-readable description of a specific value of an option or null if no special meaning
    pub fn rs2_get_option_value_description(
        options: *const rs2_options,
        option: rs2_option,
        value: f32,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Creates Depth-Colorizer processing block that can be used to quickly visualize the depth data
    /// This block will accept depth frames as input and replace them by depth frames with format RGB8
    /// Non-depth frames are passed through
    /// Further customization will be added soon (format, color-map, histogram equalization control)
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_colorizer(error: *mut *mut rs2_error) -> *mut rs2_processing_block;
}
extern "C" {
    /// Creates Sync processing block. This block accepts arbitrary frames and output composite frames of best matches
    /// Some frames may be released within the syncer if they are waiting for match for too long
    /// Syncronization is done (mostly) based on timestamps so good hardware timestamps are a pre-condition
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_sync_processing_block(
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    /// Creates Point-Cloud processing block. This block accepts depth frames and outputs Points frames
    /// In addition, given non-depth frame, the block will align texture coordinate to the non-depth stream
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_pointcloud(error: *mut *mut rs2_error) -> *mut rs2_processing_block;
}
extern "C" {
    /// Creates YUY decoder processing block. This block accepts raw YUY frames and outputs frames of other formats.
    /// YUY is a common video format used by a variety of web-cams. It benefits from packing pixels into 2 bytes per pixel
    /// without signficant quality drop. YUY representation can be converted back to more usable RGB form,
    /// but this requires somewhat costly conversion.
    /// The SDK will automatically try to use SSE2 and AVX instructions and CUDA where available to get
    /// best performance. Other implementations (using GLSL, OpenCL, Neon and NCS) should follow.
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_yuy_decoder(error: *mut *mut rs2_error) -> *mut rs2_processing_block;
}
extern "C" {
    /// Creates depth thresholding processing block
    /// By controlling min and max options on the block, one could filter out depth values
    /// that are either too large or too small, as a software post-processing step
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_threshold(error: *mut *mut rs2_error) -> *mut rs2_processing_block;
}
extern "C" {
    /// Creates depth units transformation processing block
    /// All of the pixels are transformed from depth units into meters.
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_units_transform(error: *mut *mut rs2_error) -> *mut rs2_processing_block;
}
extern "C" {
    /// This method creates new custom processing block. This lets the users pass frames between module boundaries for processing
    /// This is an infrastructure function aimed at middleware developers, and also used by provided blocks such as sync, colorizer, etc..
    /// \param proc       Processing function to be applied to every frame entering the block
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return           new processing block, to be released by rs2_delete_processing_block
    pub fn rs2_create_processing_block(
        proc_: *mut rs2_frame_processor_callback,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    /// This method creates new custom processing block from function pointer. This lets the users pass frames between module boundaries for processing
    /// This is an infrastructure function aimed at middleware developers, and also used by provided blocks such as sync, colorizer, etc..
    /// \param proc       Processing function pointer to be applied to every frame entering the block
    /// \param context    User context (can be anything or null) to be passed later as ctx param of the callback
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return           new processing block, to be released by rs2_delete_processing_block
    pub fn rs2_create_processing_block_fptr(
        proc_: rs2_frame_processor_callback_ptr,
        context: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    /// This method adds a custom option to a custom processing block. This is a simple float that can be accessed via rs2_set_option and rs2_get_option
    /// This is an infrastructure function aimed at middleware developers, and also used by provided blocks such as save_to_ply, etc..
    /// \param[in] block      Processing block
    /// \param[in] option_id  an int ID for referencing the option
    /// \param[in] min     the minimum value which will be accepted for this option
    /// \param[in] max     the maximum value which will be accepted for this option
    /// \param[in] step    the granularity of options which accept discrete values, or zero if the option accepts continuous values
    /// \param[in] def     the default value of the option. This will be the initial value.
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return            true if adding the option succeeds. false if it fails e.g. an option with this id is already registered
    pub fn rs2_processing_block_register_simple_option(
        block: *mut rs2_processing_block,
        option_id: rs2_option,
        min: f32,
        max: f32,
        step: f32,
        def: f32,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This method is used to direct the output from the processing block to some callback or sink object
    /// \param[in] block          Processing block
    /// \param[in] on_frame       Callback to be invoked every time the processing block calls frame_ready
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_start_processing(
        block: *mut rs2_processing_block,
        on_frame: *mut rs2_frame_callback,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// This method is used to direct the output from the processing block to some callback or sink object
    /// \param[in] block          Processing block
    /// \param[in] on_frame       Callback function to be invoked every time the processing block calls frame_ready
    /// \param[in] user           User context for the callback (can be anything or null)
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_start_processing_fptr(
        block: *mut rs2_processing_block,
        on_frame: rs2_frame_callback_ptr,
        user: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// This method is used to direct the output from the processing block to a dedicated queue object
    /// \param[in] block          Processing block
    /// \param[in] queue          Queue to place the processed frames to
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_start_processing_queue(
        block: *mut rs2_processing_block,
        queue: *mut rs2_frame_queue,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// This method is used to pass frame into a processing block
    /// \param[in] block          Processing block
    /// \param[in] frame          Frame to process, ownership is moved to the block object
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_process_frame(
        block: *mut rs2_processing_block,
        frame: *mut rs2_frame,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Deletes the processing block
    /// \param[in] block          Processing block
    pub fn rs2_delete_processing_block(block: *mut rs2_processing_block);
}
extern "C" {
    /// create frame queue. frame queues are the simplest x-platform synchronization primitive provided by librealsense
    /// to help developers who are not using async APIs
    /// \param[in] capacity max number of frames to allow to be stored in the queue before older frames will start to get dropped
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return handle to the frame queue, must be released using rs2_delete_frame_queue
    pub fn rs2_create_frame_queue(
        capacity: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_frame_queue;
}
extern "C" {
    /// deletes frame queue and releases all frames inside it
    /// \param[in] queue queue to delete
    pub fn rs2_delete_frame_queue(queue: *mut rs2_frame_queue);
}
extern "C" {
    /// wait until new frame becomes available in the queue and dequeue it
    /// \param[in] queue the frame queue data structure
    /// \param[in] timeout_ms   max time in milliseconds to wait until an exception will be thrown
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return frame handle to be released using rs2_release_frame
    pub fn rs2_wait_for_frame(
        queue: *mut rs2_frame_queue,
        timeout_ms: ::std::os::raw::c_uint,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_frame;
}
extern "C" {
    /// poll if a new frame is available and dequeue if it is
    /// \param[in] queue the frame queue data structure
    /// \param[out] output_frame frame handle to be released using rs2_release_frame
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return true if new frame was stored to output_frame
    pub fn rs2_poll_for_frame(
        queue: *mut rs2_frame_queue,
        output_frame: *mut *mut rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// wait until new frame becomes available in the queue and dequeue it
    /// \param[in] queue          the frame queue data structure
    /// \param[in] timeout_ms     max time in milliseconds to wait until a frame becomes available
    /// \param[out] output_frame  frame handle to be released using rs2_release_frame
    /// \param[out] error         if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return true if new frame was stored to output_frame
    pub fn rs2_try_wait_for_frame(
        queue: *mut rs2_frame_queue,
        timeout_ms: ::std::os::raw::c_uint,
        output_frame: *mut *mut rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// enqueue new frame into a queue
    /// \param[in] frame frame handle to enqueue (this operation passed ownership to the queue)
    /// \param[in] queue the frame queue data structure
    pub fn rs2_enqueue_frame(frame: *mut rs2_frame, queue: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Creates Align processing block.
    /// \param[in] align_to   stream type to be used as the target of frameset alignment
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_align(
        align_to: rs2_stream,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    /// Creates Depth post-processing filter block. This block accepts depth frames, applies decimation filter and plots modified prames
    /// Note that due to the modifiedframe size, the decimated frame repaces the original one
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_decimation_filter_block(
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    /// Creates Depth post-processing filter block. This block accepts depth frames, applies temporal filter
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_temporal_filter_block(
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    /// Creates Depth post-processing spatial filter block. This block accepts depth frames, applies spatial filters and plots modified prames
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_spatial_filter_block(error: *mut *mut rs2_error)
        -> *mut rs2_processing_block;
}
extern "C" {
    /// Creates a post processing block that provides for depth<->disparity domain transformation for stereo-based depth modules
    /// \param[in] transform_to_disparity flag select the transform direction:  true = depth->disparity, and vice versa
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_disparity_transform_block(
        transform_to_disparity: ::std::os::raw::c_uchar,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    /// Creates Depth post-processing hole filling block. The filter replaces empty pixels with data from adjacent pixels based on the method selected
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_hole_filling_filter_block(
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    /// Creates a rates printer block. The printer prints the actual FPS of the invoked frame stream.
    /// The block ignores reapiting frames and calculats the FPS only if the frame number of the relevant frame was changed.
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_rates_printer_block(error: *mut *mut rs2_error) -> *mut rs2_processing_block;
}
extern "C" {
    /// Creates Depth post-processing zero order fix block. The filter invalidates pixels that has a wrong value due to zero order effect
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               zero order fix processing block
    pub fn rs2_create_zero_order_invalidation_block(
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    /// Creates Depth frame decompression module. Decoded frames compressed and transmitted with Z16H variable-lenght Huffman code to
    /// standartized Z16 Depth data format. Using the compression allows to reduce the Depth frames bandwidth by more than 50 percent
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               Huffman-code decompression processing block
    pub fn rs2_create_huffman_depth_decompress_block(
        error: *mut *mut rs2_error,
    ) -> *mut rs2_processing_block;
}
extern "C" {
    /// Retrieve processing block specific information, like name.
    /// \param[in]  block     The processing block
    /// \param[in]  info      processing block info type to retrieve
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               The requested processing block info string, in a format specific to the device model
    pub fn rs2_get_processing_block_info(
        block: *const rs2_processing_block,
        info: rs2_camera_info,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Check if a processing block supports a specific info type.
    /// \param[in]  block     The processing block to check
    /// \param[in]  info      The parameter to check for support
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return               True if the parameter both exist and well-defined for the specific device
    pub fn rs2_supports_processing_block_info(
        block: *const rs2_processing_block,
        info: rs2_camera_info,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Test if the given processing block can be extended to the requested extension
    /// \param[in] block processing block
    /// \param[in] extension The extension to which the sensor should be tested if it is extendable
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return non-zero value iff the processing block can be extended to the given extension
    pub fn rs2_is_processing_block_extendable_to(
        block: *const rs2_processing_block,
        extension_type: rs2_extension,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
///< Unknown state
pub const rs2_playback_status_RS2_PLAYBACK_STATUS_UNKNOWN: rs2_playback_status = 0;
///< One or more sensors were started, playback is reading and raising data
pub const rs2_playback_status_RS2_PLAYBACK_STATUS_PLAYING: rs2_playback_status = 1;
///< One or more sensors were started, but playback paused reading and paused raising data
pub const rs2_playback_status_RS2_PLAYBACK_STATUS_PAUSED: rs2_playback_status = 2;
///< All sensors were stopped, or playback has ended (all data was read). This is the initial playback status
pub const rs2_playback_status_RS2_PLAYBACK_STATUS_STOPPED: rs2_playback_status = 3;
pub const rs2_playback_status_RS2_PLAYBACK_STATUS_COUNT: rs2_playback_status = 4;
pub type rs2_playback_status = u32;
extern "C" {
    pub fn rs2_playback_status_to_string(
        status: rs2_playback_status,
    ) -> *const ::std::os::raw::c_char;
}
pub type rs2_playback_status_changed_callback_ptr =
    ::std::option::Option<unsafe extern "C" fn(arg1: rs2_playback_status)>;
extern "C" {
    /// Creates a recording device to record the given device and save it to the given file
    /// \param[in]  device    The device to record
    /// \param[in]  file      The desired path to which the recorder should save the data
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return A pointer to a device that records its data to file, or null in case of failure
    pub fn rs2_create_record_device(
        device: *const rs2_device,
        file: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device;
}
extern "C" {
    /// Creates a recording device to record the given device and save it to the given file
    /// \param[in]  device                The device to record
    /// \param[in]  file                  The desired path to which the recorder should save the data
    /// \param[in]  compression_enabled   Indicates if compression is enabled, 0 means false, otherwise true
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return A pointer to a device that records its data to file, or null in case of failure
    pub fn rs2_create_record_device_ex(
        device: *const rs2_device,
        file: *const ::std::os::raw::c_char,
        compression_enabled: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device;
}
extern "C" {
    /// Pause the recording device without stopping the actual device from streaming.
    /// Pausing will cause the device to stop writing new data to the file, in particular, frames and changes to extensions
    /// \param[in]  device    A recording device
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_record_device_pause(device: *const rs2_device, error: *mut *mut rs2_error);
}
extern "C" {
    /// Unpause the recording device. Resume will cause the device to continue writing new data to the file, in particular, frames and changes to extensions
    /// \param[in]  device    A recording device
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_record_device_resume(device: *const rs2_device, error: *mut *mut rs2_error);
}
extern "C" {
    /// Gets the name of the file to which the recorder is writing
    /// \param[in]  device    A recording device
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return The  name of the file to which the recorder is writing
    pub fn rs2_record_device_filename(
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Creates a playback device to play the content of the given file
    /// \param[in]  file      Path to the file to play
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return A pointer to a device that plays data from the file, or null in case of failure
    pub fn rs2_create_playback_device(
        file: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device;
}
extern "C" {
    /// Gets the path of the file used by the playback device
    /// \param[in] device A playback device
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return Path to the file used by the playback device
    pub fn rs2_playback_device_get_file_path(
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Gets the total duration of the file in units of nanoseconds
    /// \param[in] device     A playback device
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return Total duration of the file in units of nanoseconds
    pub fn rs2_playback_get_duration(
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    /// Set the playback to a specified time point of the played data
    /// \param[in] device     A playback device.
    /// \param[in] time       The time point to which playback should seek, expressed in units of nanoseconds (zero value = start)
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_playback_seek(
        device: *const rs2_device,
        time: ::std::os::raw::c_longlong,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Gets the current position of the playback in the file in terms of time. Units are expressed in nanoseconds
    /// \param[in] device     A playback device
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return Current position of the playback in the file in terms of time. Units are expressed in nanoseconds
    pub fn rs2_playback_get_position(
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    /// Pauses the playback
    /// Calling pause() in "Paused" status does nothing
    /// If pause() is called while playback status is "Playing" or "Stopped", the playback will not play until resume() is called
    /// \param[in] device A playback device
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_playback_device_resume(device: *const rs2_device, error: *mut *mut rs2_error);
}
extern "C" {
    /// Un-pauses the playback
    /// Calling resume() while playback status is "Playing" or "Stopped" does nothing
    /// \param[in] device A playback device
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_playback_device_pause(device: *const rs2_device, error: *mut *mut rs2_error);
}
extern "C" {
    /// Set the playback to work in real time or non real time
    ///
    /// In real time mode, playback will play the same way the file was recorded.
    /// In real time mode if the application takes too long to handle the callback, frames may be dropped.
    /// In non real time mode, playback will wait for each callback to finish handling the data before
    /// reading the next frame. In this mode no frames will be dropped, and the application controls the
    /// frame rate of the playback (according to the callback handler duration).
    /// \param[in] device A playback device
    /// \param[in] real_time  Indicates if real time is requested, 0 means false, otherwise true
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_playback_device_set_real_time(
        device: *const rs2_device,
        real_time: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Indicates if playback is in real time mode or non real time
    /// \param[in] device A playback device
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return True iff playback is in real time mode. 0 means false, otherwise true
    pub fn rs2_playback_device_is_real_time(
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Register to receive callback from playback device upon its status changes
    ///
    /// Callbacks are invoked from the reading thread, any heavy processing in the callback handler will affect
    /// the reading thread and may cause frame drops\ high latency
    /// \param[in] device     A playback device
    /// \param[in] callback   A callback handler that will be invoked when the playback status changes
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_playback_device_set_status_changed_callback(
        device: *const rs2_device,
        callback: *mut rs2_playback_status_changed_callback,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Returns the current state of the playback device
    /// \param[in] device     A playback device
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return Current state of the playback
    pub fn rs2_playback_device_get_current_status(
        device: *const rs2_device,
        error: *mut *mut rs2_error,
    ) -> rs2_playback_status;
}
extern "C" {
    /// Set the playing speed
    ///
    /// \param[in] device A playback device
    /// \param[in] speed  Indicates a multiplication of the speed to play (e.g: 1 = normal, 0.5 twice as slow)
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_playback_device_set_playback_speed(
        device: *const rs2_device,
        speed: f32,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Stops the playback
    /// Calling stop() will stop all streaming playbakc sensors and will reset the playback (returning to beginning of file)
    /// \param[in] device A playback device
    /// \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_playback_device_stop(device: *const rs2_device, error: *mut *mut rs2_error);
}
extern "C" {
    /// get the size of rs2_raw_data_buffer
    /// \param[in] buffer  pointer to rs2_raw_data_buffer returned by rs2_send_and_receive_raw_data
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return size of rs2_raw_data_buffer
    pub fn rs2_get_raw_data_size(
        buffer: *const rs2_raw_data_buffer,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Delete rs2_raw_data_buffer
    /// \param[in] buffer        rs2_raw_data_buffer returned by rs2_send_and_receive_raw_data
    pub fn rs2_delete_raw_data(buffer: *const rs2_raw_data_buffer);
}
extern "C" {
    /// Retrieve char array from rs2_raw_data_buffer
    /// \param[in] buffer   rs2_raw_data_buffer returned by rs2_send_and_receive_raw_data
    /// \param[out] error   if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return raw data
    pub fn rs2_get_raw_data(
        buffer: *const rs2_raw_data_buffer,
        error: *mut *mut rs2_error,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    /// Retrieve the API version from the source code. Evaluate that the value is conformant to the established policies
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return            the version API encoded into integer value "1.9.3" -> 10903
    pub fn rs2_get_api_version(error: *mut *mut rs2_error) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rs2_log_to_console(min_severity: rs2_log_severity, error: *mut *mut rs2_error);
}
extern "C" {
    pub fn rs2_log_to_file(
        min_severity: rs2_log_severity,
        file_path: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Add custom message into librealsense log
    /// \param[in] severity  The log level for the message to be written under
    /// \param[in] message   Message to be logged
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_log(
        severity: rs2_log_severity,
        message: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Given the 2D depth coordinate (x,y) provide the corresponding depth in metric units
    /// \param[in] frame_ref  2D depth pixel coordinates (Left-Upper corner origin)
    /// \param[in] x,y  2D depth pixel coordinates (Left-Upper corner origin)
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_depth_frame_get_distance(
        frame_ref: *const rs2_frame,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    ) -> f32;
}
extern "C" {
    /// return the time at specific time point
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return            the time at specific time point, in live and record mode it will return the system time and in playback mode it will return the recorded time
    pub fn rs2_get_time(error: *mut *mut rs2_error) -> rs2_time_t;
}
extern "C" {
    /// Create a config instance
    /// The config allows pipeline users to request filters for the pipeline streams and device selection and configuration.
    /// This is an optional step in pipeline creation, as the pipeline resolves its streaming device internally.
    /// Config provides its users a way to set the filters and test if there is no conflict with the pipeline requirements
    /// from the device. It also allows the user to find a matching device for the config filters and the pipeline, in order to
    /// select a device explicitly, and modify its controls before streaming starts.
    ///
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return rs2_config*  A pointer to a new config instance
    pub fn rs2_create_config(error: *mut *mut rs2_error) -> *mut rs2_config;
}
extern "C" {
    /// Deletes an instance of a config
    ///
    /// \param[in] config    A pointer to an instance of a config
    pub fn rs2_delete_config(config: *mut rs2_config);
}
extern "C" {
    /// Enable a device stream explicitly, with selected stream parameters.
    /// The method allows the application to request a stream with specific configuration. If no stream is explicitly enabled, the pipeline
    /// configures the device and its streams according to the attached computer vision modules and processing blocks requirements, or
    /// default configuration for the first available device.
    /// The application can configure any of the input stream parameters according to its requirement, or set to 0 for don't care value.
    /// The config accumulates the application calls for enable configuration methods, until the configuration is applied. Multiple enable
    /// stream calls for the same stream with conflicting parameters override each other, and the last call is maintained.
    /// Upon calling \c resolve(), the config checks for conflicts between the application configuration requests and the attached computer
    /// vision modules and processing blocks requirements, and fails if conflicts are found. Before \c resolve() is called, no conflict
    /// check is done.
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[in] stream    Stream type to be enabled
    /// \param[in] index     Stream index, used for multiple streams of the same type. -1 indicates any.
    /// \param[in] width     Stream image width - for images streams. 0 indicates any.
    /// \param[in] height    Stream image height - for images streams. 0 indicates any.
    /// \param[in] format    Stream data format - pixel format for images streams, of data type for other streams. RS2_FORMAT_ANY indicates any.
    /// \param[in] framerate Stream frames per second. 0 indicates any.
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_enable_stream(
        config: *mut rs2_config,
        stream: rs2_stream,
        index: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        format: rs2_format,
        framerate: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Enable all device streams explicitly.
    /// The conditions and behavior of this method are similar to those of \c enable_stream().
    /// This filter enables all raw streams of the selected device. The device is either selected explicitly by the application,
    /// or by the pipeline requirements or default. The list of streams is device dependent.
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_enable_all_stream(config: *mut rs2_config, error: *mut *mut rs2_error);
}
extern "C" {
    /// Select a specific device explicitly by its serial number, to be used by the pipeline.
    /// The conditions and behavior of this method are similar to those of \c enable_stream().
    /// This method is required if the application needs to set device or sensor settings prior to pipeline streaming, to enforce
    /// the pipeline to use the configured device.
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[in] serial device serial number, as returned by RS2_CAMERA_INFO_SERIAL_NUMBER
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_enable_device(
        config: *mut rs2_config,
        serial: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Select a recorded device from a file, to be used by the pipeline through playback.
    /// The device available streams are as recorded to the file, and \c resolve() considers only this device and configuration
    /// as available.
    /// This request cannot be used if enable_record_to_file() is called for the current config, and vise versa
    /// By default, playback is repeated once the file ends. To control this, see 'rs2_config_enable_device_from_file_repeat_option'.
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[in] file      The playback file of the device
    /// \param[out] error    if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_enable_device_from_file(
        config: *mut rs2_config,
        file: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Select a recorded device from a file, to be used by the pipeline through playback.
    /// The device available streams are as recorded to the file, and \c resolve() considers only this device and configuration
    /// as available.
    /// This request cannot be used if enable_record_to_file() is called for the current config, and vise versa
    ///
    /// \param[in] config           A pointer to an instance of a config
    /// \param[in] file             The playback file of the device
    /// \param[in] repeat_playback  if true, when file ends the playback starts again, in an infinite loop;
    ///if false, when file ends playback does not start again, and should by stopped manually by the user.
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_enable_device_from_file_repeat_option(
        config: *mut rs2_config,
        file: *const ::std::os::raw::c_char,
        repeat_playback: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Requires that the resolved device would be recorded to file
    /// This request cannot be used if enable_device_from_file() is called for the current config, and vise versa
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[in] file      The desired file for the output record
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_enable_record_to_file(
        config: *mut rs2_config,
        file: *const ::std::os::raw::c_char,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Disable a device stream explicitly, to remove any requests on this stream type.
    /// The stream can still be enabled due to pipeline computer vision module request. This call removes any filter on the
    /// stream configuration.
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[in] stream    Stream type, for which the filters are cleared
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_disable_stream(
        config: *mut rs2_config,
        stream: rs2_stream,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Disable a device stream explicitly, to remove any requests on this stream profile.
    /// The stream can still be enabled due to pipeline computer vision module request. This call removes any filter on the
    /// stream configuration.
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[in] stream    Stream type, for which the filters are cleared
    /// \param[in] index     Stream index, for which the filters are cleared
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_disable_indexed_stream(
        config: *mut rs2_config,
        stream: rs2_stream,
        index: ::std::os::raw::c_int,
        error: *mut *mut rs2_error,
    );
}
extern "C" {
    /// Disable all device stream explicitly, to remove any requests on the streams profiles.
    /// The streams can still be enabled due to pipeline computer vision module request. This call removes any filter on the
    /// streams configuration.
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_config_disable_all_streams(config: *mut rs2_config, error: *mut *mut rs2_error);
}
extern "C" {
    /// Resolve the configuration filters, to find a matching device and streams profiles.
    /// The method resolves the user configuration filters for the device and streams, and combines them with the requirements of
    /// the computer vision modules and processing blocks attached to the pipeline. If there are no conflicts of requests, it looks
    /// for an available device, which can satisfy all requests, and selects the first matching streams configuration. In the absence
    /// of any request, the rs2::config selects the first available device and the first color and depth streams configuration.
    /// The pipeline profile selection during \c start() follows the same method. Thus, the selected profile is the same, if no
    /// change occurs to the available devices occurs.
    /// Resolving the pipeline configuration provides the application access to the pipeline selected device for advanced control.
    /// The returned configuration is not applied to the device, so the application doesn't own the device sensors. However, the
    /// application can call \c enable_device(), to enforce the device returned by this method is selected by pipeline \c start(),
    /// and configure the device and sensors options or extensions before streaming starts.
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[in] pipe  The pipeline for which the selected filters are applied
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return       A matching device and streams profile, which satisfies the filters and pipeline requests.
    pub fn rs2_config_resolve(
        config: *mut rs2_config,
        pipe: *mut rs2_pipeline,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline_profile;
}
extern "C" {
    /// Check if the config can resolve the configuration filters, to find a matching device and streams profiles.
    /// The resolution conditions are as described in \c resolve().
    ///
    /// \param[in] config    A pointer to an instance of a config
    /// \param[in] pipe  The pipeline for which the selected filters are applied
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return       True if a valid profile selection exists, false if no selection can be found under the config filters and the available devices.
    pub fn rs2_config_can_resolve(
        config: *mut rs2_config,
        pipe: *mut rs2_pipeline,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Create a pipeline instance
    /// The pipeline simplifies the user interaction with the device and computer vision processing modules.
    /// The class abstracts the camera configuration and streaming, and the vision modules triggering and threading.
    /// It lets the application focus on the computer vision output of the modules, or the device output data.
    /// The pipeline can manage computer vision modules, which are implemented as a processing blocks.
    /// The pipeline is the consumer of the processing block interface, while the application consumes the
    /// computer vision interface.
    /// \param[in]  ctx    context
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_create_pipeline(
        ctx: *mut rs2_context,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline;
}
extern "C" {
    /// Stop the pipeline streaming.
    /// The pipeline stops delivering samples to the attached computer vision modules and processing blocks, stops the device streaming
    /// and releases the device resources used by the pipeline. It is the application's responsibility to release any frame reference it owns.
    /// The method takes effect only after \c start() was called, otherwise an exception is raised.
    /// \param[in] pipe  pipeline
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    pub fn rs2_pipeline_stop(pipe: *mut rs2_pipeline, error: *mut *mut rs2_error);
}
extern "C" {
    /// Wait until a new set of frames becomes available.
    /// The frames set includes time-synchronized frames of each enabled stream in the pipeline.
    /// The method blocks the calling thread, and fetches the latest unread frames set.
    /// Device frames, which were produced while the function wasn't called, are dropped. To avoid frame drops, this method should be called
    /// as fast as the device frame rate.
    /// The application can maintain the frames handles to defer processing. However, if the application maintains too long history, the device
    /// may lack memory resources to produce new frames, and the following call to this method shall fail to retrieve new frames, until resources
    /// are retained.
    /// \param[in] pipe the pipeline
    /// \param[in] timeout_ms   Max time in milliseconds to wait until an exception will be thrown
    /// \param[out] error         if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return Set of coherent frames
    pub fn rs2_pipeline_wait_for_frames(
        pipe: *mut rs2_pipeline,
        timeout_ms: ::std::os::raw::c_uint,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_frame;
}
extern "C" {
    /// Check if a new set of frames is available and retrieve the latest undelivered set.
    /// The frames set includes time-synchronized frames of each enabled stream in the pipeline.
    /// The method returns without blocking the calling thread, with status of new frames available or not. If available, it fetches the
    /// latest frames set.
    /// Device frames, which were produced while the function wasn't called, are dropped. To avoid frame drops, this method should be called
    /// as fast as the device frame rate.
    /// The application can maintain the frames handles to defer processing. However, if the application maintains too long history, the device
    /// may lack memory resources to produce new frames, and the following calls to this method shall return no new frames, until resources are
    /// retained.
    /// \param[in] pipe the pipeline
    /// \param[out] output_frame frame handle to be released using rs2_release_frame
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return true if new frame was stored to output_frame
    pub fn rs2_pipeline_poll_for_frames(
        pipe: *mut rs2_pipeline,
        output_frame: *mut *mut rs2_frame,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Wait until a new set of frames becomes available.
    /// The frames set includes time-synchronized frames of each enabled stream in the pipeline.
    /// The method blocks the calling thread, and fetches the latest unread frames set.
    /// Device frames, which were produced while the function wasn't called, are dropped. To avoid frame drops, this method should be called
    /// as fast as the device frame rate.
    /// The application can maintain the frames handles to defer processing. However, if the application maintains too long history, the device
    /// may lack memory resources to produce new frames, and the following call to this method shall fail to retrieve new frames, until resources
    /// are retained.
    /// \param[in] pipe           the pipeline
    /// \param[in] timeout_ms     max time in milliseconds to wait until a frame becomes available
    /// \param[out] output_frame  frame handle to be released using rs2_release_frame
    /// \param[out] error         if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return true if new frame was stored to output_frame
    pub fn rs2_pipeline_try_wait_for_frames(
        pipe: *mut rs2_pipeline,
        output_frame: *mut *mut rs2_frame,
        timeout_ms: ::std::os::raw::c_uint,
        error: *mut *mut rs2_error,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Delete a pipeline instance.
    /// Upon destruction, the pipeline will implicitly stop itself
    /// \param[in] pipe to delete
    pub fn rs2_delete_pipeline(pipe: *mut rs2_pipeline);
}
extern "C" {
    /// Start the pipeline streaming with its default configuration.
    /// The pipeline streaming loop captures samples from the device, and delivers them to the attached computer vision modules
    /// and processing blocks, according to each module requirements and threading model.
    /// During the loop execution, the application can access the camera streams by calling \c wait_for_frames() or \c poll_for_frames().
    /// The streaming loop runs until the pipeline is stopped.
    /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
    ///
    /// \param[in] pipe    a pointer to an instance of the pipeline
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
    pub fn rs2_pipeline_start(
        pipe: *mut rs2_pipeline,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline_profile;
}
extern "C" {
    /// Start the pipeline streaming according to the configuraion.
    /// The pipeline streaming loop captures samples from the device, and delivers them to the attached computer vision modules
    /// and processing blocks, according to each module requirements and threading model.
    /// During the loop execution, the application can access the camera streams by calling \c wait_for_frames() or \c poll_for_frames().
    /// The streaming loop runs until the pipeline is stopped.
    /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
    /// The pipeline selects and activates the device upon start, according to configuration or a default configuration.
    /// When the rs2::config is provided to the method, the pipeline tries to activate the config \c resolve() result. If the application
    /// requests are conflicting with pipeline computer vision modules or no matching device is available on the platform, the method fails.
    /// Available configurations and devices may change between config \c resolve() call and pipeline start, in case devices are connected
    /// or disconnected, or another application acquires ownership of a device.
    ///
    /// \param[in] pipe    a pointer to an instance of the pipeline
    /// \param[in] config   A rs2::config with requested filters on the pipeline configuration. By default no filters are applied.
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
    pub fn rs2_pipeline_start_with_config(
        pipe: *mut rs2_pipeline,
        config: *mut rs2_config,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline_profile;
}
extern "C" {
    /// Start the pipeline streaming with its default configuration.
    /// The pipeline captures samples from the device, and delivers them to the through the provided frame callback.
    /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
    /// When starting the pipeline with a callback both \c wait_for_frames() or \c poll_for_frames() will throw exception.
    ///
    /// \param[in] pipe     A pointer to an instance of the pipeline
    /// \param[in] on_frame function pointer to register as per-frame callback
    /// \param[in] user auxiliary  data the user wishes to receive together with every frame callback
    /// \param[out] error   If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
    pub fn rs2_pipeline_start_with_callback(
        pipe: *mut rs2_pipeline,
        on_frame: rs2_frame_callback_ptr,
        user: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline_profile;
}
extern "C" {
    /// Start the pipeline streaming with its default configuration.
    /// The pipeline captures samples from the device, and delivers them to the through the provided frame callback.
    /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
    /// When starting the pipeline with a callback both \c wait_for_frames() or \c poll_for_frames() will throw exception.
    ///
    /// \param[in] pipe     A pointer to an instance of the pipeline
    /// \param[in] callback callback object created from c++ application. ownership over the callback object is moved into the relevant streaming lock
    /// \param[out] error   If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
    pub fn rs2_pipeline_start_with_callback_cpp(
        pipe: *mut rs2_pipeline,
        callback: *mut rs2_frame_callback,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline_profile;
}
extern "C" {
    /// Start the pipeline streaming according to the configuraion.
    /// The pipeline captures samples from the device, and delivers them to the through the provided frame callback.
    /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
    /// When starting the pipeline with a callback both \c wait_for_frames() or \c poll_for_frames() will throw exception.
    /// The pipeline selects and activates the device upon start, according to configuration or a default configuration.
    /// When the rs2::config is provided to the method, the pipeline tries to activate the config \c resolve() result. If the application
    /// requests are conflicting with pipeline computer vision modules or no matching device is available on the platform, the method fails.
    /// Available configurations and devices may change between config \c resolve() call and pipeline start, in case devices are connected
    /// or disconnected, or another application acquires ownership of a device.
    ///
    /// \param[in] pipe     A pointer to an instance of the pipeline
    /// \param[in] config   A rs2::config with requested filters on the pipeline configuration. By default no filters are applied.
    /// \param[in] on_frame function pointer to register as per-frame callback
    /// \param[in] user auxiliary  data the user wishes to receive together with every frame callback
    /// \param[out] error   If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
    pub fn rs2_pipeline_start_with_config_and_callback(
        pipe: *mut rs2_pipeline,
        config: *mut rs2_config,
        on_frame: rs2_frame_callback_ptr,
        user: *mut ::std::os::raw::c_void,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline_profile;
}
extern "C" {
    /// Start the pipeline streaming according to the configuraion.
    /// The pipeline captures samples from the device, and delivers them to the through the provided frame callback.
    /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
    /// When starting the pipeline with a callback both \c wait_for_frames() or \c poll_for_frames() will throw exception.
    /// The pipeline selects and activates the device upon start, according to configuration or a default configuration.
    /// When the rs2::config is provided to the method, the pipeline tries to activate the config \c resolve() result. If the application
    /// requests are conflicting with pipeline computer vision modules or no matching device is available on the platform, the method fails.
    /// Available configurations and devices may change between config \c resolve() call and pipeline start, in case devices are connected
    /// or disconnected, or another application acquires ownership of a device.
    ///
    /// \param[in] pipe     A pointer to an instance of the pipeline
    /// \param[in] config   A rs2::config with requested filters on the pipeline configuration. By default no filters are applied.
    /// \param[in] callback callback object created from c++ application. ownership over the callback object is moved into the relevant streaming lock
    /// \param[out] error   If non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
    pub fn rs2_pipeline_start_with_config_and_callback_cpp(
        pipe: *mut rs2_pipeline,
        config: *mut rs2_config,
        callback: *mut rs2_frame_callback,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline_profile;
}
extern "C" {
    /// Return the active device and streams profiles, used by the pipeline.
    /// The pipeline streams profiles are selected during \c start(). The method returns a valid result only when the pipeline is active -
    /// between calls to \c start() and \c stop().
    /// After \c stop() is called, the pipeline doesn't own the device, thus, the pipeline selected device may change in subsequent activations.
    ///
    /// \param[in] pipe    a pointer to an instance of the pipeline
    /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return  The actual pipeline device and streams profile, which was successfully configured to the streaming device on start.
    pub fn rs2_pipeline_get_active_profile(
        pipe: *mut rs2_pipeline,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_pipeline_profile;
}
extern "C" {
    /// Retrieve the device used by the pipeline.
    /// The device class provides the application access to control camera additional settings -
    /// get device information, sensor options information, options value query and set, sensor specific extensions.
    /// Since the pipeline controls the device streams configuration, activation state and frames reading, calling
    /// the device API functions, which execute those operations, results in unexpected behavior.
    /// The pipeline streaming device is selected during pipeline \c start(). Devices of profiles, which are not returned by
    /// pipeline \c start() or \c get_active_profile(), are not guaranteed to be used by the pipeline.
    ///
    /// \param[in] profile    A pointer to an instance of a pipeline profile
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return rs2_device* The pipeline selected device
    pub fn rs2_pipeline_profile_get_device(
        profile: *mut rs2_pipeline_profile,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_device;
}
extern "C" {
    /// Return the selected streams profiles, which are enabled in this profile.
    ///
    /// \param[in] profile    A pointer to an instance of a pipeline profile
    /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
    /// \return   list of stream profiles
    pub fn rs2_pipeline_profile_get_streams(
        profile: *mut rs2_pipeline_profile,
        error: *mut *mut rs2_error,
    ) -> *mut rs2_stream_profile_list;
}
extern "C" {
    /// Deletes an instance of a pipeline profile
    ///
    /// \param[in] profile    A pointer to an instance of a pipeline profile
    pub fn rs2_delete_pipeline_profile(profile: *mut rs2_pipeline_profile);
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STDepthControlGroup {
    pub plusIncrement: u32,
    pub minusDecrement: u32,
    pub deepSeaMedianThreshold: u32,
    pub scoreThreshA: u32,
    pub scoreThreshB: u32,
    pub textureDifferenceThreshold: u32,
    pub textureCountThreshold: u32,
    pub deepSeaSecondPeakThreshold: u32,
    pub deepSeaNeighborThreshold: u32,
    pub lrAgreeThreshold: u32,
}
#[test]
fn bindgen_test_layout_STDepthControlGroup() {
    assert_eq!(
        ::std::mem::size_of::<STDepthControlGroup>(),
        40usize,
        concat!("Size of: ", stringify!(STDepthControlGroup))
    );
    assert_eq!(
        ::std::mem::align_of::<STDepthControlGroup>(),
        4usize,
        concat!("Alignment of ", stringify!(STDepthControlGroup))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STDepthControlGroup>())).plusIncrement as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STDepthControlGroup),
            "::",
            stringify!(plusIncrement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STDepthControlGroup>())).minusDecrement as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(STDepthControlGroup),
            "::",
            stringify!(minusDecrement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STDepthControlGroup>())).deepSeaMedianThreshold as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(STDepthControlGroup),
            "::",
            stringify!(deepSeaMedianThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STDepthControlGroup>())).scoreThreshA as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(STDepthControlGroup),
            "::",
            stringify!(scoreThreshA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STDepthControlGroup>())).scoreThreshB as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(STDepthControlGroup),
            "::",
            stringify!(scoreThreshB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STDepthControlGroup>())).textureDifferenceThreshold as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(STDepthControlGroup),
            "::",
            stringify!(textureDifferenceThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STDepthControlGroup>())).textureCountThreshold as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(STDepthControlGroup),
            "::",
            stringify!(textureCountThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STDepthControlGroup>())).deepSeaSecondPeakThreshold as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(STDepthControlGroup),
            "::",
            stringify!(deepSeaSecondPeakThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STDepthControlGroup>())).deepSeaNeighborThreshold as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(STDepthControlGroup),
            "::",
            stringify!(deepSeaNeighborThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STDepthControlGroup>())).lrAgreeThreshold as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(STDepthControlGroup),
            "::",
            stringify!(lrAgreeThreshold)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STRsm {
    pub rsmBypass: u32,
    pub diffThresh: f32,
    pub sloRauDiffThresh: f32,
    pub removeThresh: u32,
}
#[test]
fn bindgen_test_layout_STRsm() {
    assert_eq!(
        ::std::mem::size_of::<STRsm>(),
        16usize,
        concat!("Size of: ", stringify!(STRsm))
    );
    assert_eq!(
        ::std::mem::align_of::<STRsm>(),
        4usize,
        concat!("Alignment of ", stringify!(STRsm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STRsm>())).rsmBypass as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STRsm),
            "::",
            stringify!(rsmBypass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STRsm>())).diffThresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(STRsm),
            "::",
            stringify!(diffThresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STRsm>())).sloRauDiffThresh as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(STRsm),
            "::",
            stringify!(sloRauDiffThresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STRsm>())).removeThresh as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(STRsm),
            "::",
            stringify!(removeThresh)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STRauSupportVectorControl {
    pub minWest: u32,
    pub minEast: u32,
    pub minWEsum: u32,
    pub minNorth: u32,
    pub minSouth: u32,
    pub minNSsum: u32,
    pub uShrink: u32,
    pub vShrink: u32,
}
#[test]
fn bindgen_test_layout_STRauSupportVectorControl() {
    assert_eq!(
        ::std::mem::size_of::<STRauSupportVectorControl>(),
        32usize,
        concat!("Size of: ", stringify!(STRauSupportVectorControl))
    );
    assert_eq!(
        ::std::mem::align_of::<STRauSupportVectorControl>(),
        4usize,
        concat!("Alignment of ", stringify!(STRauSupportVectorControl))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STRauSupportVectorControl>())).minWest as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STRauSupportVectorControl),
            "::",
            stringify!(minWest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STRauSupportVectorControl>())).minEast as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(STRauSupportVectorControl),
            "::",
            stringify!(minEast)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STRauSupportVectorControl>())).minWEsum as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(STRauSupportVectorControl),
            "::",
            stringify!(minWEsum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STRauSupportVectorControl>())).minNorth as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(STRauSupportVectorControl),
            "::",
            stringify!(minNorth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STRauSupportVectorControl>())).minSouth as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(STRauSupportVectorControl),
            "::",
            stringify!(minSouth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STRauSupportVectorControl>())).minNSsum as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(STRauSupportVectorControl),
            "::",
            stringify!(minNSsum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STRauSupportVectorControl>())).uShrink as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(STRauSupportVectorControl),
            "::",
            stringify!(uShrink)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STRauSupportVectorControl>())).vShrink as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(STRauSupportVectorControl),
            "::",
            stringify!(vShrink)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STColorControl {
    pub disableSADColor: u32,
    pub disableRAUColor: u32,
    pub disableSLORightColor: u32,
    pub disableSLOLeftColor: u32,
    pub disableSADNormalize: u32,
}
#[test]
fn bindgen_test_layout_STColorControl() {
    assert_eq!(
        ::std::mem::size_of::<STColorControl>(),
        20usize,
        concat!("Size of: ", stringify!(STColorControl))
    );
    assert_eq!(
        ::std::mem::align_of::<STColorControl>(),
        4usize,
        concat!("Alignment of ", stringify!(STColorControl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STColorControl>())).disableSADColor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorControl),
            "::",
            stringify!(disableSADColor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STColorControl>())).disableRAUColor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorControl),
            "::",
            stringify!(disableRAUColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STColorControl>())).disableSLORightColor as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorControl),
            "::",
            stringify!(disableSLORightColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STColorControl>())).disableSLOLeftColor as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorControl),
            "::",
            stringify!(disableSLOLeftColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STColorControl>())).disableSADNormalize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorControl),
            "::",
            stringify!(disableSADNormalize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STRauColorThresholdsControl {
    pub rauDiffThresholdRed: u32,
    pub rauDiffThresholdGreen: u32,
    pub rauDiffThresholdBlue: u32,
}
#[test]
fn bindgen_test_layout_STRauColorThresholdsControl() {
    assert_eq!(
        ::std::mem::size_of::<STRauColorThresholdsControl>(),
        12usize,
        concat!("Size of: ", stringify!(STRauColorThresholdsControl))
    );
    assert_eq!(
        ::std::mem::align_of::<STRauColorThresholdsControl>(),
        4usize,
        concat!("Alignment of ", stringify!(STRauColorThresholdsControl))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STRauColorThresholdsControl>())).rauDiffThresholdRed as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STRauColorThresholdsControl),
            "::",
            stringify!(rauDiffThresholdRed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STRauColorThresholdsControl>())).rauDiffThresholdGreen
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(STRauColorThresholdsControl),
            "::",
            stringify!(rauDiffThresholdGreen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STRauColorThresholdsControl>())).rauDiffThresholdBlue as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(STRauColorThresholdsControl),
            "::",
            stringify!(rauDiffThresholdBlue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STSloColorThresholdsControl {
    pub diffThresholdRed: u32,
    pub diffThresholdGreen: u32,
    pub diffThresholdBlue: u32,
}
#[test]
fn bindgen_test_layout_STSloColorThresholdsControl() {
    assert_eq!(
        ::std::mem::size_of::<STSloColorThresholdsControl>(),
        12usize,
        concat!("Size of: ", stringify!(STSloColorThresholdsControl))
    );
    assert_eq!(
        ::std::mem::align_of::<STSloColorThresholdsControl>(),
        4usize,
        concat!("Alignment of ", stringify!(STSloColorThresholdsControl))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STSloColorThresholdsControl>())).diffThresholdRed as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STSloColorThresholdsControl),
            "::",
            stringify!(diffThresholdRed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STSloColorThresholdsControl>())).diffThresholdGreen as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(STSloColorThresholdsControl),
            "::",
            stringify!(diffThresholdGreen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STSloColorThresholdsControl>())).diffThresholdBlue as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(STSloColorThresholdsControl),
            "::",
            stringify!(diffThresholdBlue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STSloPenaltyControl {
    pub sloK1Penalty: u32,
    pub sloK2Penalty: u32,
    pub sloK1PenaltyMod1: u32,
    pub sloK2PenaltyMod1: u32,
    pub sloK1PenaltyMod2: u32,
    pub sloK2PenaltyMod2: u32,
}
#[test]
fn bindgen_test_layout_STSloPenaltyControl() {
    assert_eq!(
        ::std::mem::size_of::<STSloPenaltyControl>(),
        24usize,
        concat!("Size of: ", stringify!(STSloPenaltyControl))
    );
    assert_eq!(
        ::std::mem::align_of::<STSloPenaltyControl>(),
        4usize,
        concat!("Alignment of ", stringify!(STSloPenaltyControl))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STSloPenaltyControl>())).sloK1Penalty as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STSloPenaltyControl),
            "::",
            stringify!(sloK1Penalty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STSloPenaltyControl>())).sloK2Penalty as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(STSloPenaltyControl),
            "::",
            stringify!(sloK2Penalty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STSloPenaltyControl>())).sloK1PenaltyMod1 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(STSloPenaltyControl),
            "::",
            stringify!(sloK1PenaltyMod1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STSloPenaltyControl>())).sloK2PenaltyMod1 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(STSloPenaltyControl),
            "::",
            stringify!(sloK2PenaltyMod1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STSloPenaltyControl>())).sloK1PenaltyMod2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(STSloPenaltyControl),
            "::",
            stringify!(sloK1PenaltyMod2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STSloPenaltyControl>())).sloK2PenaltyMod2 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(STSloPenaltyControl),
            "::",
            stringify!(sloK2PenaltyMod2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STHdad {
    pub lambdaCensus: f32,
    pub lambdaAD: f32,
    pub ignoreSAD: u32,
}
#[test]
fn bindgen_test_layout_STHdad() {
    assert_eq!(
        ::std::mem::size_of::<STHdad>(),
        12usize,
        concat!("Size of: ", stringify!(STHdad))
    );
    assert_eq!(
        ::std::mem::align_of::<STHdad>(),
        4usize,
        concat!("Alignment of ", stringify!(STHdad))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STHdad>())).lambdaCensus as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STHdad),
            "::",
            stringify!(lambdaCensus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STHdad>())).lambdaAD as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(STHdad),
            "::",
            stringify!(lambdaAD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STHdad>())).ignoreSAD as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(STHdad),
            "::",
            stringify!(ignoreSAD)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STColorCorrection {
    pub colorCorrection1: f32,
    pub colorCorrection2: f32,
    pub colorCorrection3: f32,
    pub colorCorrection4: f32,
    pub colorCorrection5: f32,
    pub colorCorrection6: f32,
    pub colorCorrection7: f32,
    pub colorCorrection8: f32,
    pub colorCorrection9: f32,
    pub colorCorrection10: f32,
    pub colorCorrection11: f32,
    pub colorCorrection12: f32,
}
#[test]
fn bindgen_test_layout_STColorCorrection() {
    assert_eq!(
        ::std::mem::size_of::<STColorCorrection>(),
        48usize,
        concat!("Size of: ", stringify!(STColorCorrection))
    );
    assert_eq!(
        ::std::mem::align_of::<STColorCorrection>(),
        4usize,
        concat!("Alignment of ", stringify!(STColorCorrection))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STColorCorrection>())).colorCorrection1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorCorrection),
            "::",
            stringify!(colorCorrection1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STColorCorrection>())).colorCorrection2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorCorrection),
            "::",
            stringify!(colorCorrection2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STColorCorrection>())).colorCorrection3 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorCorrection),
            "::",
            stringify!(colorCorrection3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STColorCorrection>())).colorCorrection4 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorCorrection),
            "::",
            stringify!(colorCorrection4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STColorCorrection>())).colorCorrection5 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorCorrection),
            "::",
            stringify!(colorCorrection5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STColorCorrection>())).colorCorrection6 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorCorrection),
            "::",
            stringify!(colorCorrection6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STColorCorrection>())).colorCorrection7 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorCorrection),
            "::",
            stringify!(colorCorrection7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STColorCorrection>())).colorCorrection8 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorCorrection),
            "::",
            stringify!(colorCorrection8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STColorCorrection>())).colorCorrection9 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorCorrection),
            "::",
            stringify!(colorCorrection9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STColorCorrection>())).colorCorrection10 as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorCorrection),
            "::",
            stringify!(colorCorrection10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STColorCorrection>())).colorCorrection11 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorCorrection),
            "::",
            stringify!(colorCorrection11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STColorCorrection>())).colorCorrection12 as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(STColorCorrection),
            "::",
            stringify!(colorCorrection12)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STAEControl {
    pub meanIntensitySetPoint: u32,
}
#[test]
fn bindgen_test_layout_STAEControl() {
    assert_eq!(
        ::std::mem::size_of::<STAEControl>(),
        4usize,
        concat!("Size of: ", stringify!(STAEControl))
    );
    assert_eq!(
        ::std::mem::align_of::<STAEControl>(),
        4usize,
        concat!("Alignment of ", stringify!(STAEControl))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STAEControl>())).meanIntensitySetPoint as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STAEControl),
            "::",
            stringify!(meanIntensitySetPoint)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STDepthTableControl {
    pub depthUnits: u32,
    pub depthClampMin: i32,
    pub depthClampMax: i32,
    pub disparityMode: u32,
    pub disparityShift: i32,
}
#[test]
fn bindgen_test_layout_STDepthTableControl() {
    assert_eq!(
        ::std::mem::size_of::<STDepthTableControl>(),
        20usize,
        concat!("Size of: ", stringify!(STDepthTableControl))
    );
    assert_eq!(
        ::std::mem::align_of::<STDepthTableControl>(),
        4usize,
        concat!("Alignment of ", stringify!(STDepthTableControl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STDepthTableControl>())).depthUnits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STDepthTableControl),
            "::",
            stringify!(depthUnits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STDepthTableControl>())).depthClampMin as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(STDepthTableControl),
            "::",
            stringify!(depthClampMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STDepthTableControl>())).depthClampMax as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(STDepthTableControl),
            "::",
            stringify!(depthClampMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STDepthTableControl>())).disparityMode as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(STDepthTableControl),
            "::",
            stringify!(disparityMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<STDepthTableControl>())).disparityShift as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(STDepthTableControl),
            "::",
            stringify!(disparityShift)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STCensusRadius {
    pub uDiameter: u32,
    pub vDiameter: u32,
}
#[test]
fn bindgen_test_layout_STCensusRadius() {
    assert_eq!(
        ::std::mem::size_of::<STCensusRadius>(),
        8usize,
        concat!("Size of: ", stringify!(STCensusRadius))
    );
    assert_eq!(
        ::std::mem::align_of::<STCensusRadius>(),
        4usize,
        concat!("Alignment of ", stringify!(STCensusRadius))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STCensusRadius>())).uDiameter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STCensusRadius),
            "::",
            stringify!(uDiameter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STCensusRadius>())).vDiameter as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(STCensusRadius),
            "::",
            stringify!(vDiameter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STAFactor {
    pub amplitude: f32,
}
#[test]
fn bindgen_test_layout_STAFactor() {
    assert_eq!(
        ::std::mem::size_of::<STAFactor>(),
        4usize,
        concat!("Size of: ", stringify!(STAFactor))
    );
    assert_eq!(
        ::std::mem::align_of::<STAFactor>(),
        4usize,
        concat!("Alignment of ", stringify!(STAFactor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<STAFactor>())).amplitude as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STAFactor),
            "::",
            stringify!(amplitude)
        )
    );
}
